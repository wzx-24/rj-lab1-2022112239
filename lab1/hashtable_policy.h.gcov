        -:    0:Source:D:/mingw64/lib/gcc/x86_64-w64-mingw32/14.2.0/include/c++/bits/hashtable_policy.h
        -:    0:Graph:test_shortestPath-lab1.gcno
        -:    0:Data:test_shortestPath-lab1.gcda
        -:    0:Runs:7
        -:    1:// Internal policy header for unordered_set and unordered_map -*- C++ -*-
        -:    2:
        -:    3:// Copyright (C) 2010-2024 Free Software Foundation, Inc.
        -:    4://
        -:    5:// This file is part of the GNU ISO C++ Library.  This library is free
        -:    6:// software; you can redistribute it and/or modify it under the
        -:    7:// terms of the GNU General Public License as published by the
        -:    8:// Free Software Foundation; either version 3, or (at your option)
        -:    9:// any later version.
        -:   10:
        -:   11:// This library is distributed in the hope that it will be useful,
        -:   12:// but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   13:// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   14:// GNU General Public License for more details.
        -:   15:
        -:   16:// Under Section 7 of GPL version 3, you are granted additional
        -:   17:// permissions described in the GCC Runtime Library Exception, version
        -:   18:// 3.1, as published by the Free Software Foundation.
        -:   19:
        -:   20:// You should have received a copy of the GNU General Public License and
        -:   21:// a copy of the GCC Runtime Library Exception along with this program;
        -:   22:// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
        -:   23:// <http://www.gnu.org/licenses/>.
        -:   24:
        -:   25:/** @file bits/hashtable_policy.h
        -:   26: *  This is an internal header file, included by other library headers.
        -:   27: *  Do not attempt to use it directly.
        -:   28: *  @headername{unordered_map,unordered_set}
        -:   29: */
        -:   30:
        -:   31:#ifndef _HASHTABLE_POLICY_H
        -:   32:#define _HASHTABLE_POLICY_H 1
        -:   33:
        -:   34:#include <tuple>		// for std::tuple, std::forward_as_tuple
        -:   35:#include <bits/functional_hash.h> // for __is_fast_hash
        -:   36:#include <bits/stl_algobase.h>	// for std::min, std::is_permutation.
        -:   37:#include <bits/stl_pair.h>	// for std::pair
        -:   38:#include <ext/aligned_buffer.h>	// for __gnu_cxx::__aligned_buffer
        -:   39:#include <ext/alloc_traits.h>	// for std::__alloc_rebind
        -:   40:#include <ext/numeric_traits.h>	// for __gnu_cxx::__int_traits
        -:   41:
        -:   42:namespace std _GLIBCXX_VISIBILITY(default)
        -:   43:{
        -:   44:_GLIBCXX_BEGIN_NAMESPACE_VERSION
        -:   45:/// @cond undocumented
        -:   46:
        -:   47:  template<typename _Key, typename _Value, typename _Alloc,
        -:   48:	   typename _ExtractKey, typename _Equal,
        -:   49:	   typename _Hash, typename _RangeHash, typename _Unused,
        -:   50:	   typename _RehashPolicy, typename _Traits>
        -:   51:    class _Hashtable;
        -:   52:
        -:   53:namespace __detail
        -:   54:{
        -:   55:  /**
        -:   56:   *  @defgroup hashtable-detail Base and Implementation Classes
        -:   57:   *  @ingroup unordered_associative_containers
        -:   58:   *  @{
        -:   59:   */
        -:   60:  template<typename _Key, typename _Value, typename _ExtractKey,
        -:   61:	   typename _Equal, typename _Hash, typename _RangeHash,
        -:   62:	   typename _Unused, typename _Traits>
        -:   63:    struct _Hashtable_base;
        -:   64:
        -:   65:  // Helper function: return distance(first, last) for forward
        -:   66:  // iterators, or 0/1 for input iterators.
        -:   67:  template<typename _Iterator>
        -:   68:    inline typename std::iterator_traits<_Iterator>::difference_type
        -:   69:    __distance_fw(_Iterator __first, _Iterator __last,
        -:   70:		  std::input_iterator_tag)
        -:   71:    { return __first != __last ? 1 : 0; }
        -:   72:
        -:   73:  template<typename _Iterator>
        -:   74:    inline typename std::iterator_traits<_Iterator>::difference_type
        -:   75:    __distance_fw(_Iterator __first, _Iterator __last,
        -:   76:		  std::forward_iterator_tag)
        -:   77:    { return std::distance(__first, __last); }
        -:   78:
        -:   79:  template<typename _Iterator>
        -:   80:    inline typename std::iterator_traits<_Iterator>::difference_type
        -:   81:    __distance_fw(_Iterator __first, _Iterator __last)
        -:   82:    { return __distance_fw(__first, __last,
        -:   83:			   std::__iterator_category(__first)); }
        -:   84:
        -:   85:  struct _Identity
        -:   86:  {
        -:   87:    template<typename _Tp>
        -:   88:      _Tp&&
      746:   89:      operator()(_Tp&& __x) const noexcept
      746:   90:      { return std::forward<_Tp>(__x); }
        -:   91:  };
        -:   92:
        -:   93:  struct _Select1st
        -:   94:  {
        -:   95:    template<typename _Pair>
        -:   96:      struct __1st_type;
        -:   97:
        -:   98:    template<typename _Tp, typename _Up>
        -:   99:      struct __1st_type<pair<_Tp, _Up>>
        -:  100:      { using type = _Tp; };
        -:  101:
        -:  102:    template<typename _Tp, typename _Up>
        -:  103:      struct __1st_type<const pair<_Tp, _Up>>
        -:  104:      { using type = const _Tp; };
        -:  105:
        -:  106:    template<typename _Pair>
        -:  107:      struct __1st_type<_Pair&>
        -:  108:      { using type = typename __1st_type<_Pair>::type&; };
        -:  109:
        -:  110:    template<typename _Tp>
        -:  111:      typename __1st_type<_Tp>::type&&
     507*:  112:      operator()(_Tp&& __x) const noexcept
     507*:  113:      { return std::forward<_Tp>(__x).first; }
------------------
_ZNKSt8__detail10_Select1stclIRKSt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEdEEEONS0_10__1st_typeIT_E4typeEOSE_:
    #####:  112:      operator()(_Tp&& __x) const noexcept
    #####:  113:      { return std::forward<_Tp>(__x).first; }
------------------
_ZNKSt8__detail10_Select1stclIRKSt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt6vectorIS8_SaIS8_EEEEEONS0_10__1st_typeIT_E4typeEOSH_:
    #####:  112:      operator()(_Tp&& __x) const noexcept
    #####:  113:      { return std::forward<_Tp>(__x).first; }
------------------
_ZNKSt8__detail10_Select1stclIRKSt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_EEEONS0_10__1st_typeIT_E4typeEOSE_:
      105:  112:      operator()(_Tp&& __x) const noexcept
      105:  113:      { return std::forward<_Tp>(__x).first; }
------------------
_ZNKSt8__detail10_Select1stclIRKSt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEiEEEONS0_10__1st_typeIT_E4typeEOSE_:
      353:  112:      operator()(_Tp&& __x) const noexcept
      353:  113:      { return std::forward<_Tp>(__x).first; }
------------------
_ZNKSt8__detail10_Select1stclIRKSt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt13unordered_mapIS8_iSt4hashIS8_ESt8equal_toIS8_ESaIS2_IS9_iEEEEEEONS0_10__1st_typeIT_E4typeEOSM_:
       49:  112:      operator()(_Tp&& __x) const noexcept
       49:  113:      { return std::forward<_Tp>(__x).first; }
------------------
        -:  114:  };
        -:  115:
        -:  116:  template<typename _ExKey, typename _Value>
        -:  117:    struct _ConvertToValueType;
        -:  118:
        -:  119:  template<typename _Value>
        -:  120:    struct _ConvertToValueType<_Identity, _Value>
        -:  121:    {
        -:  122:      template<typename _Kt>
        -:  123:	constexpr _Kt&&
      227:  124:	operator()(_Kt&& __k) const noexcept
      227:  125:	{ return std::forward<_Kt>(__k); }
        -:  126:    };
        -:  127:
        -:  128:  template<typename _Value>
        -:  129:    struct _ConvertToValueType<_Select1st, _Value>
        -:  130:    {
        -:  131:      constexpr _Value&&
        -:  132:      operator()(_Value&& __x) const noexcept
        -:  133:      { return std::move(__x); }
        -:  134:
        -:  135:      constexpr const _Value&
        -:  136:      operator()(const _Value& __x) const noexcept
        -:  137:      { return __x; }
        -:  138:
        -:  139:      template<typename _Kt, typename _Val>
        -:  140:	constexpr std::pair<_Kt, _Val>&&
        -:  141:	operator()(std::pair<_Kt, _Val>&& __x) const noexcept
        -:  142:	{ return std::move(__x); }
        -:  143:
        -:  144:      template<typename _Kt, typename _Val>
        -:  145:	constexpr const std::pair<_Kt, _Val>&
        -:  146:	operator()(const std::pair<_Kt, _Val>& __x) const noexcept
        -:  147:	{ return __x; }
        -:  148:    };
        -:  149:
        -:  150:  template<typename _ExKey>
        -:  151:    struct _NodeBuilder;
        -:  152:
        -:  153:  template<>
        -:  154:    struct _NodeBuilder<_Select1st>
        -:  155:    {
        -:  156:      template<typename _Kt, typename _Arg, typename _NodeGenerator>
        -:  157:	static auto
        -:  158:	_S_build(_Kt&& __k, _Arg&& __arg, const _NodeGenerator& __node_gen)
        -:  159:	-> typename _NodeGenerator::__node_ptr
        -:  160:	{
        -:  161:	  return __node_gen(std::forward<_Kt>(__k),
        -:  162:			    std::forward<_Arg>(__arg).second);
        -:  163:	}
        -:  164:    };
        -:  165:
        -:  166:  template<>
        -:  167:    struct _NodeBuilder<_Identity>
        -:  168:    {
        -:  169:      template<typename _Kt, typename _Arg, typename _NodeGenerator>
        -:  170:	static auto
      125:  171:	_S_build(_Kt&& __k, _Arg&&, const _NodeGenerator& __node_gen)
        -:  172:	-> typename _NodeGenerator::__node_ptr
      125:  173:	{ return __node_gen(std::forward<_Kt>(__k)); }
        -:  174:    };
        -:  175:
        -:  176:  template<typename _HashtableAlloc, typename _NodePtr>
        -:  177:    struct _NodePtrGuard
        -:  178:    {
        -:  179:      _HashtableAlloc& _M_h;
        -:  180:      _NodePtr _M_ptr;
        -:  181:
        -:  182:      ~_NodePtrGuard()
        -:  183:      {
        -:  184:	if (_M_ptr)
        -:  185:	  _M_h._M_deallocate_node_ptr(_M_ptr);
        -:  186:      }
        -:  187:    };
        -:  188:
        -:  189:  template<typename _NodeAlloc>
        -:  190:    struct _Hashtable_alloc;
        -:  191:
        -:  192:  // Functor recycling a pool of nodes and using allocation once the pool is
        -:  193:  // empty.
        -:  194:  template<typename _NodeAlloc>
        -:  195:    struct _ReuseOrAllocNode
        -:  196:    {
        -:  197:    private:
        -:  198:      using __node_alloc_type = _NodeAlloc;
        -:  199:      using __hashtable_alloc = _Hashtable_alloc<__node_alloc_type>;
        -:  200:      using __node_alloc_traits =
        -:  201:	typename __hashtable_alloc::__node_alloc_traits;
        -:  202:
        -:  203:    public:
        -:  204:      using __node_ptr = typename __hashtable_alloc::__node_ptr;
        -:  205:
        -:  206:      _ReuseOrAllocNode(__node_ptr __nodes, __hashtable_alloc& __h)
        -:  207:      : _M_nodes(__nodes), _M_h(__h) { }
        -:  208:      _ReuseOrAllocNode(const _ReuseOrAllocNode&) = delete;
        -:  209:
        -:  210:      ~_ReuseOrAllocNode()
        -:  211:      { _M_h._M_deallocate_nodes(_M_nodes); }
        -:  212:
        -:  213:      template<typename... _Args>
        -:  214:	__node_ptr
        -:  215:	operator()(_Args&&... __args) const
        -:  216:	{
        -:  217:	  if (!_M_nodes)
        -:  218:	    return _M_h._M_allocate_node(std::forward<_Args>(__args)...);
        -:  219:
        -:  220:	  __node_ptr __node = _M_nodes;
        -:  221:	  _M_nodes = _M_nodes->_M_next();
        -:  222:	  __node->_M_nxt = nullptr;
        -:  223:	  auto& __a = _M_h._M_node_allocator();
        -:  224:	  __node_alloc_traits::destroy(__a, __node->_M_valptr());
        -:  225:	  _NodePtrGuard<__hashtable_alloc, __node_ptr> __guard { _M_h, __node };
        -:  226:	  __node_alloc_traits::construct(__a, __node->_M_valptr(),
        -:  227:					 std::forward<_Args>(__args)...);
        -:  228:	  __guard._M_ptr = nullptr;
        -:  229:	  return __node;
        -:  230:	}
        -:  231:
        -:  232:    private:
        -:  233:      mutable __node_ptr _M_nodes;
        -:  234:      __hashtable_alloc& _M_h;
        -:  235:    };
        -:  236:
        -:  237:  // Functor similar to the previous one but without any pool of nodes to
        -:  238:  // recycle.
        -:  239:  template<typename _NodeAlloc>
        -:  240:    struct _AllocNode
        -:  241:    {
        -:  242:    private:
        -:  243:      using __hashtable_alloc = _Hashtable_alloc<_NodeAlloc>;
        -:  244:
        -:  245:    public:
        -:  246:      using __node_ptr = typename __hashtable_alloc::__node_ptr;
        -:  247:
      227:  248:      _AllocNode(__hashtable_alloc& __h)
      227:  249:      : _M_h(__h) { }
        -:  250:
        -:  251:      template<typename... _Args>
        -:  252:	__node_ptr
      125:  253:	operator()(_Args&&... __args) const
      125:  254:	{ return _M_h._M_allocate_node(std::forward<_Args>(__args)...); }
        -:  255:
        -:  256:    private:
        -:  257:      __hashtable_alloc& _M_h;
        -:  258:    };
        -:  259:
        -:  260:  // Auxiliary types used for all instantiations of _Hashtable nodes
        -:  261:  // and iterators.
        -:  262:
        -:  263:  /**
        -:  264:   *  struct _Hashtable_traits
        -:  265:   *
        -:  266:   *  Important traits for hash tables.
        -:  267:   *
        -:  268:   *  @tparam _Cache_hash_code  Boolean value. True if the value of
        -:  269:   *  the hash function is stored along with the value. This is a
        -:  270:   *  time-space tradeoff.  Storing it may improve lookup speed by
        -:  271:   *  reducing the number of times we need to call the _Hash or _Equal
        -:  272:   *  functors.
        -:  273:   *
        -:  274:   *  @tparam _Constant_iterators  Boolean value. True if iterator and
        -:  275:   *  const_iterator are both constant iterator types. This is true
        -:  276:   *  for unordered_set and unordered_multiset, false for
        -:  277:   *  unordered_map and unordered_multimap.
        -:  278:   *
        -:  279:   *  @tparam _Unique_keys  Boolean value. True if the return value
        -:  280:   *  of _Hashtable::count(k) is always at most one, false if it may
        -:  281:   *  be an arbitrary number. This is true for unordered_set and
        -:  282:   *  unordered_map, false for unordered_multiset and
        -:  283:   *  unordered_multimap.
        -:  284:   */
        -:  285:  template<bool _Cache_hash_code, bool _Constant_iterators, bool _Unique_keys>
        -:  286:    struct _Hashtable_traits
        -:  287:    {
        -:  288:      using __hash_cached = __bool_constant<_Cache_hash_code>;
        -:  289:      using __constant_iterators = __bool_constant<_Constant_iterators>;
        -:  290:      using __unique_keys = __bool_constant<_Unique_keys>;
        -:  291:    };
        -:  292:
        -:  293:  /**
        -:  294:   *  struct _Hashtable_hash_traits
        -:  295:   *
        -:  296:   *  Important traits for hash tables depending on associated hasher.
        -:  297:   *
        -:  298:   */
        -:  299:  template<typename _Hash>
        -:  300:    struct _Hashtable_hash_traits
        -:  301:    {
        -:  302:      static constexpr std::size_t
      454:  303:      __small_size_threshold() noexcept
      454:  304:      { return std::__is_fast_hash<_Hash>::value ? 0 : 20; }
        -:  305:    };
        -:  306:
        -:  307:  /**
        -:  308:   *  struct _Hash_node_base
        -:  309:   *
        -:  310:   *  Nodes, used to wrap elements stored in the hash table.  A policy
        -:  311:   *  template parameter of class template _Hashtable controls whether
        -:  312:   *  nodes also store a hash code. In some cases (e.g. strings) this
        -:  313:   *  may be a performance win.
        -:  314:   */
        -:  315:  struct _Hash_node_base
        -:  316:  {
        -:  317:    _Hash_node_base* _M_nxt;
        -:  318:
      760:  319:    _Hash_node_base() noexcept : _M_nxt() { }
------------------
_ZNSt8__detail15_Hash_node_baseC1Ev:
      183:  319:    _Hash_node_base() noexcept : _M_nxt() { }
------------------
_ZNSt8__detail15_Hash_node_baseC2Ev:
      577:  319:    _Hash_node_base() noexcept : _M_nxt() { }
------------------
        -:  320:
    #####:  321:    _Hash_node_base(_Hash_node_base* __next) noexcept : _M_nxt(__next) { }
        -:  322:  };
        -:  323:
        -:  324:  /**
        -:  325:   *  struct _Hash_node_value_base
        -:  326:   *
        -:  327:   *  Node type with the value to store.
        -:  328:   */
        -:  329:  template<typename _Value>
        -:  330:    struct _Hash_node_value_base
        -:  331:    {
        -:  332:      typedef _Value value_type;
        -:  333:
        -:  334:      __gnu_cxx::__aligned_buffer<_Value> _M_storage;
        -:  335:
        -:  336:      [[__gnu__::__always_inline__]]
        -:  337:      _Value*
        -:  338:      _M_valptr() noexcept
    2118*:  339:      { return _M_storage._M_ptr(); }
        -:  340:
        -:  341:      [[__gnu__::__always_inline__]]
        -:  342:      const _Value*
        -:  343:      _M_valptr() const noexcept
    1026*:  344:      { return _M_storage._M_ptr(); }
        -:  345:
        -:  346:      [[__gnu__::__always_inline__]]
        -:  347:      _Value&
        -:  348:      _M_v() noexcept
     611*:  349:      { return *_M_valptr(); }
        -:  350:
        -:  351:      [[__gnu__::__always_inline__]]
        -:  352:      const _Value&
        -:  353:      _M_v() const noexcept
    1026*:  354:      { return *_M_valptr(); }
        -:  355:    };
        -:  356:
        -:  357:  /**
        -:  358:   *  Primary template struct _Hash_node_code_cache.
        -:  359:   */
        -:  360:  template<bool _Cache_hash_code>
        -:  361:    struct _Hash_node_code_cache
        -:  362:    { };
        -:  363:
        -:  364:  /**
        -:  365:   *  Specialization for node with cache, struct _Hash_node_code_cache.
        -:  366:   */
        -:  367:  template<>
        -:  368:    struct _Hash_node_code_cache<true>
        -:  369:    { std::size_t  _M_hash_code; };
        -:  370:
        -:  371:  template<typename _Value, bool _Cache_hash_code>
        -:  372:    struct _Hash_node_value
        -:  373:    : _Hash_node_value_base<_Value>
        -:  374:    , _Hash_node_code_cache<_Cache_hash_code>
        -:  375:    { };
        -:  376:
        -:  377:  /**
        -:  378:   *  Primary template struct _Hash_node.
        -:  379:   */
        -:  380:  template<typename _Value, bool _Cache_hash_code>
        -:  381:    struct _Hash_node
        -:  382:    : _Hash_node_base
        -:  383:    , _Hash_node_value<_Value, _Cache_hash_code>
        -:  384:    {
        -:  385:      _Hash_node*
    1498*:  386:      _M_next() const noexcept
    1498*:  387:      { return static_cast<_Hash_node*>(this->_M_nxt); }
------------------
_ZNKSt8__detail10_Hash_nodeISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEdELb1EE7_M_nextEv:
    #####:  386:      _M_next() const noexcept
    #####:  387:      { return static_cast<_Hash_node*>(this->_M_nxt); }
------------------
_ZNKSt8__detail10_Hash_nodeISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES7_ELb1EE7_M_nextEv:
      112:  386:      _M_next() const noexcept
      112:  387:      { return static_cast<_Hash_node*>(this->_M_nxt); }
------------------
_ZNKSt8__detail10_Hash_nodeISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt6vectorIS7_SaIS7_EEELb1EE7_M_nextEv:
      127:  386:      _M_next() const noexcept
      127:  387:      { return static_cast<_Hash_node*>(this->_M_nxt); }
------------------
_ZNKSt8__detail10_Hash_nodeISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEiELb1EE7_M_nextEv:
      478:  386:      _M_next() const noexcept
      478:  387:      { return static_cast<_Hash_node*>(this->_M_nxt); }
------------------
_ZNKSt8__detail10_Hash_nodeISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt13unordered_mapIS7_iSt4hashIS7_ESt8equal_toIS7_ESaIS1_IS8_iEEEELb1EE7_M_nextEv:
      119:  386:      _M_next() const noexcept
      119:  387:      { return static_cast<_Hash_node*>(this->_M_nxt); }
------------------
_ZNKSt8__detail10_Hash_nodeINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEELb1EE7_M_nextEv:
      662:  386:      _M_next() const noexcept
      662:  387:      { return static_cast<_Hash_node*>(this->_M_nxt); }
------------------
        -:  388:    };
        -:  389:
        -:  390:  /// Base class for node iterators.
        -:  391:  template<typename _Value, bool _Cache_hash_code>
        -:  392:    struct _Node_iterator_base
        -:  393:    {
        -:  394:      using __node_type = _Hash_node<_Value, _Cache_hash_code>;
        -:  395:
        -:  396:      __node_type* _M_cur;
        -:  397:
        -:  398:      _Node_iterator_base() : _M_cur(nullptr) { }
     939*:  399:      _Node_iterator_base(__node_type* __p) noexcept
     939*:  400:      : _M_cur(__p) { }
------------------
_ZNSt8__detail19_Node_iterator_baseISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEdELb1EEC2EPNS_10_Hash_nodeIS9_Lb1EEE:
    #####:  399:      _Node_iterator_base(__node_type* __p) noexcept
    #####:  400:      : _M_cur(__p) { }
------------------
_ZNSt8__detail19_Node_iterator_baseISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES7_ELb1EEC2EPNS_10_Hash_nodeIS9_Lb1EEE:
       84:  399:      _Node_iterator_base(__node_type* __p) noexcept
       84:  400:      : _M_cur(__p) { }
------------------
_ZNSt8__detail19_Node_iterator_baseISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt6vectorIS7_SaIS7_EEELb1EEC2EPNS_10_Hash_nodeISC_Lb1EEE:
       95:  399:      _Node_iterator_base(__node_type* __p) noexcept
       95:  400:      : _M_cur(__p) { }
------------------
_ZNSt8__detail19_Node_iterator_baseISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEiELb1EEC2EPNS_10_Hash_nodeIS9_Lb1EEE:
      304:  399:      _Node_iterator_base(__node_type* __p) noexcept
      304:  400:      : _M_cur(__p) { }
------------------
_ZNSt8__detail19_Node_iterator_baseISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt13unordered_mapIS7_iSt4hashIS7_ESt8equal_toIS7_ESaIS1_IS8_iEEEELb1EEC2EPNS_10_Hash_nodeISH_Lb1EEE:
       88:  399:      _Node_iterator_base(__node_type* __p) noexcept
       88:  400:      : _M_cur(__p) { }
------------------
_ZNSt8__detail19_Node_iterator_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEELb1EEC2EPNS_10_Hash_nodeIS6_Lb1EEE:
      368:  399:      _Node_iterator_base(__node_type* __p) noexcept
      368:  400:      : _M_cur(__p) { }
------------------
        -:  401:
        -:  402:      void
     174*:  403:      _M_incr() noexcept
     174*:  404:      { _M_cur = _M_cur->_M_next(); }
------------------
_ZNSt8__detail19_Node_iterator_baseISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEiELb1EE7_M_incrEv:
       49:  403:      _M_incr() noexcept
       49:  404:      { _M_cur = _M_cur->_M_next(); }
------------------
_ZNSt8__detail19_Node_iterator_baseISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt13unordered_mapIS7_iSt4hashIS7_ESt8equal_toIS7_ESaIS1_IS8_iEEEELb1EE7_M_incrEv:
    #####:  403:      _M_incr() noexcept
    #####:  404:      { _M_cur = _M_cur->_M_next(); }
------------------
_ZNSt8__detail19_Node_iterator_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEELb1EE7_M_incrEv:
      125:  403:      _M_incr() noexcept
      125:  404:      { _M_cur = _M_cur->_M_next(); }
------------------
        -:  405:
        -:  406:      friend bool
        -:  407:      operator==(const _Node_iterator_base& __x, const _Node_iterator_base& __y)
        -:  408:      noexcept
        -:  409:      { return __x._M_cur == __y._M_cur; }
        -:  410:
        -:  411:#if __cpp_impl_three_way_comparison < 201907L
        -:  412:      friend bool
     253*:  413:      operator!=(const _Node_iterator_base& __x, const _Node_iterator_base& __y)
        -:  414:      noexcept
     253*:  415:      { return __x._M_cur != __y._M_cur; }
------------------
_ZNSt8__detailneERKNS_19_Node_iterator_baseISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEiELb1EEESC_:
       91:  413:      operator!=(const _Node_iterator_base& __x, const _Node_iterator_base& __y)
        -:  414:      noexcept
       91:  415:      { return __x._M_cur != __y._M_cur; }
------------------
_ZNSt8__detailneERKNS_19_Node_iterator_baseISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt13unordered_mapIS7_iSt4hashIS7_ESt8equal_toIS7_ESaIS1_IS8_iEEEELb1EEESK_:
    #####:  413:      operator!=(const _Node_iterator_base& __x, const _Node_iterator_base& __y)
        -:  414:      noexcept
    #####:  415:      { return __x._M_cur != __y._M_cur; }
------------------
_ZNSt8__detailneERKNS_19_Node_iterator_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEELb1EEES9_:
      162:  413:      operator!=(const _Node_iterator_base& __x, const _Node_iterator_base& __y)
        -:  414:      noexcept
      162:  415:      { return __x._M_cur != __y._M_cur; }
------------------
        -:  416:#endif
        -:  417:    };
        -:  418:
        -:  419:  /// Node iterators, used to iterate through all the hashtable.
        -:  420:  template<typename _Value, bool __constant_iterators, bool __cache>
        -:  421:    struct _Node_iterator
        -:  422:    : public _Node_iterator_base<_Value, __cache>
        -:  423:    {
        -:  424:    private:
        -:  425:      using __base_type = _Node_iterator_base<_Value, __cache>;
        -:  426:      using __node_type = typename __base_type::__node_type;
        -:  427:
        -:  428:    public:
        -:  429:      using value_type = _Value;
        -:  430:      using difference_type = std::ptrdiff_t;
        -:  431:      using iterator_category = std::forward_iterator_tag;
        -:  432:
        -:  433:      using pointer = __conditional_t<__constant_iterators,
        -:  434:				      const value_type*, value_type*>;
        -:  435:
        -:  436:      using reference = __conditional_t<__constant_iterators,
        -:  437:					const value_type&, value_type&>;
        -:  438:
        -:  439:      _Node_iterator() = default;
        -:  440:
        -:  441:      explicit
     837*:  442:      _Node_iterator(__node_type* __p) noexcept
     837*:  443:      : __base_type(__p) { }
------------------
_ZNSt8__detail14_Node_iteratorISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEdELb0ELb1EEC1EPNS_10_Hash_nodeIS9_Lb1EEE:
    #####:  442:      _Node_iterator(__node_type* __p) noexcept
    #####:  443:      : __base_type(__p) { }
------------------
_ZNSt8__detail14_Node_iteratorISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES7_ELb0ELb1EEC1EPNS_10_Hash_nodeIS9_Lb1EEE:
       49:  442:      _Node_iterator(__node_type* __p) noexcept
       49:  443:      : __base_type(__p) { }
------------------
_ZNSt8__detail14_Node_iteratorISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt6vectorIS7_SaIS7_EEELb0ELb1EEC1EPNS_10_Hash_nodeISC_Lb1EEE:
       95:  442:      _Node_iterator(__node_type* __p) noexcept
       95:  443:      : __base_type(__p) { }
------------------
_ZNSt8__detail14_Node_iteratorISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEiELb0ELb1EEC1EPNS_10_Hash_nodeIS9_Lb1EEE:
      304:  442:      _Node_iterator(__node_type* __p) noexcept
      304:  443:      : __base_type(__p) { }
------------------
_ZNSt8__detail14_Node_iteratorISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt13unordered_mapIS7_iSt4hashIS7_ESt8equal_toIS7_ESaIS1_IS8_iEEEELb0ELb1EEC1EPNS_10_Hash_nodeISH_Lb1EEE:
       88:  442:      _Node_iterator(__node_type* __p) noexcept
       88:  443:      : __base_type(__p) { }
------------------
_ZNSt8__detail14_Node_iteratorINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEELb1ELb1EEC1EPNS_10_Hash_nodeIS6_Lb1EEE:
      301:  442:      _Node_iterator(__node_type* __p) noexcept
      301:  443:      : __base_type(__p) { }
------------------
        -:  444:
        -:  445:      reference
     174*:  446:      operator*() const noexcept
     348*:  447:      { return this->_M_cur->_M_v(); }
------------------
_ZNKSt8__detail14_Node_iteratorISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEiELb0ELb1EEdeEv:
       49:  446:      operator*() const noexcept
       98:  447:      { return this->_M_cur->_M_v(); }
------------------
_ZNKSt8__detail14_Node_iteratorISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt13unordered_mapIS7_iSt4hashIS7_ESt8equal_toIS7_ESaIS1_IS8_iEEEELb0ELb1EEdeEv:
    #####:  446:      operator*() const noexcept
    #####:  447:      { return this->_M_cur->_M_v(); }
------------------
_ZNKSt8__detail14_Node_iteratorINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEELb1ELb1EEdeEv:
      125:  446:      operator*() const noexcept
      250:  447:      { return this->_M_cur->_M_v(); }
------------------
        -:  448:
        -:  449:      pointer
     452*:  450:      operator->() const noexcept
     904*:  451:      { return this->_M_cur->_M_valptr(); }
------------------
_ZNKSt8__detail14_Node_iteratorISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEdELb0ELb1EEptEv:
    #####:  450:      operator->() const noexcept
    #####:  451:      { return this->_M_cur->_M_valptr(); }
------------------
_ZNKSt8__detail14_Node_iteratorISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES7_ELb0ELb1EEptEv:
       49:  450:      operator->() const noexcept
       98:  451:      { return this->_M_cur->_M_valptr(); }
------------------
_ZNKSt8__detail14_Node_iteratorISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt6vectorIS7_SaIS7_EEELb0ELb1EEptEv:
       95:  450:      operator->() const noexcept
      190:  451:      { return this->_M_cur->_M_valptr(); }
------------------
_ZNKSt8__detail14_Node_iteratorISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEiELb0ELb1EEptEv:
      220:  450:      operator->() const noexcept
      440:  451:      { return this->_M_cur->_M_valptr(); }
------------------
_ZNKSt8__detail14_Node_iteratorISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt13unordered_mapIS7_iSt4hashIS7_ESt8equal_toIS7_ESaIS1_IS8_iEEEELb0ELb1EEptEv:
       88:  450:      operator->() const noexcept
      176:  451:      { return this->_M_cur->_M_valptr(); }
------------------
        -:  452:
        -:  453:      _Node_iterator&
     174*:  454:      operator++() noexcept
        -:  455:      {
     174*:  456:	this->_M_incr();
     174*:  457:	return *this;
        -:  458:      }
------------------
_ZNSt8__detail14_Node_iteratorISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEiELb0ELb1EEppEv:
       49:  454:      operator++() noexcept
        -:  455:      {
       49:  456:	this->_M_incr();
       49:  457:	return *this;
        -:  458:      }
------------------
_ZNSt8__detail14_Node_iteratorISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt13unordered_mapIS7_iSt4hashIS7_ESt8equal_toIS7_ESaIS1_IS8_iEEEELb0ELb1EEppEv:
    #####:  454:      operator++() noexcept
        -:  455:      {
    #####:  456:	this->_M_incr();
    #####:  457:	return *this;
        -:  458:      }
------------------
_ZNSt8__detail14_Node_iteratorINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEELb1ELb1EEppEv:
      125:  454:      operator++() noexcept
        -:  455:      {
      125:  456:	this->_M_incr();
      125:  457:	return *this;
        -:  458:      }
------------------
        -:  459:
        -:  460:      _Node_iterator
        -:  461:      operator++(int) noexcept
        -:  462:      {
        -:  463:	_Node_iterator __tmp(*this);
        -:  464:	this->_M_incr();
        -:  465:	return __tmp;
        -:  466:      }
        -:  467:    };
        -:  468:
        -:  469:  /// Node const_iterators, used to iterate through all the hashtable.
        -:  470:  template<typename _Value, bool __constant_iterators, bool __cache>
        -:  471:    struct _Node_const_iterator
        -:  472:    : public _Node_iterator_base<_Value, __cache>
        -:  473:    {
        -:  474:    private:
        -:  475:      using __base_type = _Node_iterator_base<_Value, __cache>;
        -:  476:      using __node_type = typename __base_type::__node_type;
        -:  477:
        -:  478:    public:
        -:  479:      typedef _Value					value_type;
        -:  480:      typedef std::ptrdiff_t				difference_type;
        -:  481:      typedef std::forward_iterator_tag			iterator_category;
        -:  482:
        -:  483:      typedef const value_type*				pointer;
        -:  484:      typedef const value_type&				reference;
        -:  485:
        -:  486:      _Node_const_iterator() = default;
        -:  487:
        -:  488:      explicit
     102*:  489:      _Node_const_iterator(__node_type* __p) noexcept
     102*:  490:      : __base_type(__p) { }
------------------
_ZNSt8__detail20_Node_const_iteratorISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES7_ELb0ELb1EEC1EPNS_10_Hash_nodeIS9_Lb1EEE:
       35:  489:      _Node_const_iterator(__node_type* __p) noexcept
       35:  490:      : __base_type(__p) { }
------------------
_ZNSt8__detail20_Node_const_iteratorISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt13unordered_mapIS7_iSt4hashIS7_ESt8equal_toIS7_ESaIS1_IS8_iEEEELb0ELb1EEC1EPNS_10_Hash_nodeISH_Lb1EEE:
    #####:  489:      _Node_const_iterator(__node_type* __p) noexcept
    #####:  490:      : __base_type(__p) { }
------------------
_ZNSt8__detail20_Node_const_iteratorINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEELb1ELb1EEC1EPNS_10_Hash_nodeIS6_Lb1EEE:
       67:  489:      _Node_const_iterator(__node_type* __p) noexcept
       67:  490:      : __base_type(__p) { }
------------------
_ZNSt8__detail20_Node_const_iteratorISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEiELb0ELb1EEC1EPNS_10_Hash_nodeIS9_Lb1EEE:
    #####:  489:      _Node_const_iterator(__node_type* __p) noexcept
    #####:  490:      : __base_type(__p) { }
------------------
        -:  491:
        -:  492:      _Node_const_iterator(const _Node_iterator<_Value, __constant_iterators,
        -:  493:			   __cache>& __x) noexcept
        -:  494:      : __base_type(__x._M_cur) { }
        -:  495:
        -:  496:      reference
    #####:  497:      operator*() const noexcept
    #####:  498:      { return this->_M_cur->_M_v(); }
        -:  499:
        -:  500:      pointer
        -:  501:      operator->() const noexcept
        -:  502:      { return this->_M_cur->_M_valptr(); }
        -:  503:
        -:  504:      _Node_const_iterator&
    #####:  505:      operator++() noexcept
        -:  506:      {
    #####:  507:	this->_M_incr();
    #####:  508:	return *this;
        -:  509:      }
        -:  510:
        -:  511:      _Node_const_iterator
        -:  512:      operator++(int) noexcept
        -:  513:      {
        -:  514:	_Node_const_iterator __tmp(*this);
        -:  515:	this->_M_incr();
        -:  516:	return __tmp;
        -:  517:      }
        -:  518:    };
        -:  519:
        -:  520:  // Many of class template _Hashtable's template parameters are policy
        -:  521:  // classes.  These are defaults for the policies.
        -:  522:
        -:  523:  /// Default range hashing function: use division to fold a large number
        -:  524:  /// into the range [0, N).
        -:  525:  struct _Mod_range_hashing
        -:  526:  {
        -:  527:    typedef std::size_t first_argument_type;
        -:  528:    typedef std::size_t second_argument_type;
        -:  529:    typedef std::size_t result_type;
        -:  530:
        -:  531:    result_type
     1557:  532:    operator()(first_argument_type __num,
        -:  533:	       second_argument_type __den) const noexcept
     1557:  534:    { return __num % __den; }
        -:  535:  };
        -:  536:
        -:  537:  /// Default ranged hash function H.  In principle it should be a
        -:  538:  /// function object composed from objects of type H1 and H2 such that
        -:  539:  /// h(k, N) = h2(h1(k), N), but that would mean making extra copies of
        -:  540:  /// h1 and h2.  So instead we'll just use a tag to tell class template
        -:  541:  /// hashtable to do that composition.
        -:  542:  struct _Default_ranged_hash { };
        -:  543:
        -:  544:  /// Default value for rehash policy.  Bucket size is (usually) the
        -:  545:  /// smallest prime that keeps the load factor small enough.
        -:  546:  struct _Prime_rehash_policy
        -:  547:  {
        -:  548:    using __has_load_factor = true_type;
        -:  549:
      183:  550:    _Prime_rehash_policy(float __z = 1.0) noexcept
      183:  551:    : _M_max_load_factor(__z), _M_next_resize(0) { }
        -:  552:
        -:  553:    float
        -:  554:    max_load_factor() const noexcept
        -:  555:    { return _M_max_load_factor; }
        -:  556:
        -:  557:    // Return a bucket size no smaller than n.
        -:  558:    std::size_t
        -:  559:    _M_next_bkt(std::size_t __n) const;
        -:  560:
        -:  561:    // Return a bucket count appropriate for n elements
        -:  562:    std::size_t
        -:  563:    _M_bkt_for_elements(std::size_t __n) const
        -:  564:    { return __builtin_ceil(__n / (double)_M_max_load_factor); }
        -:  565:
        -:  566:    // __n_bkt is current bucket count, __n_elt is current element count,
        -:  567:    // and __n_ins is number of elements to be inserted.  Do we need to
        -:  568:    // increase bucket count?  If so, return make_pair(true, n), where n
        -:  569:    // is the new bucket count.  If not, return make_pair(false, 0).
        -:  570:    std::pair<bool, std::size_t>
        -:  571:    _M_need_rehash(std::size_t __n_bkt, std::size_t __n_elt,
        -:  572:		   std::size_t __n_ins) const;
        -:  573:
        -:  574:    typedef std::size_t _State;
        -:  575:
        -:  576:    _State
      577:  577:    _M_state() const
      577:  578:    { return _M_next_resize; }
        -:  579:
        -:  580:    void
    #####:  581:    _M_reset() noexcept
    #####:  582:    { _M_next_resize = 0; }
        -:  583:
        -:  584:    void
    #####:  585:    _M_reset(_State __state)
    #####:  586:    { _M_next_resize = __state; }
        -:  587:
        -:  588:    static const std::size_t _S_growth_factor = 2;
        -:  589:
        -:  590:    float		_M_max_load_factor;
        -:  591:    mutable std::size_t	_M_next_resize;
        -:  592:  };
        -:  593:
        -:  594:  /// Range hashing function assuming that second arg is a power of 2.
        -:  595:  struct _Mask_range_hashing
        -:  596:  {
        -:  597:    typedef std::size_t first_argument_type;
        -:  598:    typedef std::size_t second_argument_type;
        -:  599:    typedef std::size_t result_type;
        -:  600:
        -:  601:    result_type
        -:  602:    operator()(first_argument_type __num,
        -:  603:	       second_argument_type __den) const noexcept
        -:  604:    { return __num & (__den - 1); }
        -:  605:  };
        -:  606:
        -:  607:  /// Compute closest power of 2 not less than __n
        -:  608:  inline std::size_t
        -:  609:  __clp2(std::size_t __n) noexcept
        -:  610:  {
        -:  611:    using __gnu_cxx::__int_traits;
        -:  612:    // Equivalent to return __n ? std::bit_ceil(__n) : 0;
        -:  613:    if (__n < 2)
        -:  614:      return __n;
        -:  615:    const unsigned __lz = sizeof(size_t) > sizeof(long)
        -:  616:      ? __builtin_clzll(__n - 1ull)
        -:  617:      : __builtin_clzl(__n - 1ul);
        -:  618:    // Doing two shifts avoids undefined behaviour when __lz == 0.
        -:  619:    return (size_t(1) << (__int_traits<size_t>::__digits - __lz - 1)) << 1;
        -:  620:  }
        -:  621:
        -:  622:  /// Rehash policy providing power of 2 bucket numbers. Avoids modulo
        -:  623:  /// operations.
        -:  624:  struct _Power2_rehash_policy
        -:  625:  {
        -:  626:    using __has_load_factor = true_type;
        -:  627:
        -:  628:    _Power2_rehash_policy(float __z = 1.0) noexcept
        -:  629:    : _M_max_load_factor(__z), _M_next_resize(0) { }
        -:  630:
        -:  631:    float
        -:  632:    max_load_factor() const noexcept
        -:  633:    { return _M_max_load_factor; }
        -:  634:
        -:  635:    // Return a bucket size no smaller than n (as long as n is not above the
        -:  636:    // highest power of 2).
        -:  637:    std::size_t
        -:  638:    _M_next_bkt(std::size_t __n) noexcept
        -:  639:    {
        -:  640:      if (__n == 0)
        -:  641:	// Special case on container 1st initialization with 0 bucket count
        -:  642:	// hint. We keep _M_next_resize to 0 to make sure that next time we
        -:  643:	// want to add an element allocation will take place.
        -:  644:	return 1;
        -:  645:
        -:  646:      const auto __max_width = std::min<size_t>(sizeof(size_t), 8);
        -:  647:      const auto __max_bkt = size_t(1) << (__max_width * __CHAR_BIT__ - 1);
        -:  648:      std::size_t __res = __clp2(__n);
        -:  649:
        -:  650:      if (__res == 0)
        -:  651:	__res = __max_bkt;
        -:  652:      else if (__res == 1)
        -:  653:	// If __res is 1 we force it to 2 to make sure there will be an
        -:  654:	// allocation so that nothing need to be stored in the initial
        -:  655:	// single bucket
        -:  656:	__res = 2;
        -:  657:
        -:  658:      if (__res == __max_bkt)
        -:  659:	// Set next resize to the max value so that we never try to rehash again
        -:  660:	// as we already reach the biggest possible bucket number.
        -:  661:	// Note that it might result in max_load_factor not being respected.
        -:  662:	_M_next_resize = size_t(-1);
        -:  663:      else
        -:  664:	_M_next_resize
        -:  665:	  = __builtin_floor(__res * (double)_M_max_load_factor);
        -:  666:
        -:  667:      return __res;
        -:  668:    }
        -:  669:
        -:  670:    // Return a bucket count appropriate for n elements
        -:  671:    std::size_t
        -:  672:    _M_bkt_for_elements(std::size_t __n) const noexcept
        -:  673:    { return __builtin_ceil(__n / (double)_M_max_load_factor); }
        -:  674:
        -:  675:    // __n_bkt is current bucket count, __n_elt is current element count,
        -:  676:    // and __n_ins is number of elements to be inserted.  Do we need to
        -:  677:    // increase bucket count?  If so, return make_pair(true, n), where n
        -:  678:    // is the new bucket count.  If not, return make_pair(false, 0).
        -:  679:    std::pair<bool, std::size_t>
        -:  680:    _M_need_rehash(std::size_t __n_bkt, std::size_t __n_elt,
        -:  681:		   std::size_t __n_ins) noexcept
        -:  682:    {
        -:  683:      if (__n_elt + __n_ins > _M_next_resize)
        -:  684:	{
        -:  685:	  // If _M_next_resize is 0 it means that we have nothing allocated so
        -:  686:	  // far and that we start inserting elements. In this case we start
        -:  687:	  // with an initial bucket size of 11.
        -:  688:	  double __min_bkts
        -:  689:	    = std::max<std::size_t>(__n_elt + __n_ins, _M_next_resize ? 0 : 11)
        -:  690:	      / (double)_M_max_load_factor;
        -:  691:	  if (__min_bkts >= __n_bkt)
        -:  692:	    return { true,
        -:  693:	      _M_next_bkt(std::max<std::size_t>(__builtin_floor(__min_bkts) + 1,
        -:  694:						__n_bkt * _S_growth_factor)) };
        -:  695:
        -:  696:	  _M_next_resize
        -:  697:	    = __builtin_floor(__n_bkt * (double)_M_max_load_factor);
        -:  698:	  return { false, 0 };
        -:  699:	}
        -:  700:      else
        -:  701:	return { false, 0 };
        -:  702:    }
        -:  703:
        -:  704:    typedef std::size_t _State;
        -:  705:
        -:  706:    _State
        -:  707:    _M_state() const noexcept
        -:  708:    { return _M_next_resize; }
        -:  709:
        -:  710:    void
        -:  711:    _M_reset() noexcept
        -:  712:    { _M_next_resize = 0; }
        -:  713:
        -:  714:    void
        -:  715:    _M_reset(_State __state) noexcept
        -:  716:    { _M_next_resize = __state; }
        -:  717:
        -:  718:    static const std::size_t _S_growth_factor = 2;
        -:  719:
        -:  720:    float	_M_max_load_factor;
        -:  721:    std::size_t	_M_next_resize;
        -:  722:  };
        -:  723:
        -:  724:  template<typename _RehashPolicy>
        -:  725:    struct _RehashStateGuard
        -:  726:    {
        -:  727:      _RehashPolicy* _M_guarded_obj;
        -:  728:      typename _RehashPolicy::_State _M_prev_state;
        -:  729:
      577:  730:      _RehashStateGuard(_RehashPolicy& __policy)
      577:  731:      : _M_guarded_obj(std::__addressof(__policy))
      577:  732:      , _M_prev_state(__policy._M_state())
      577:  733:      { }
        -:  734:      _RehashStateGuard(const _RehashStateGuard&) = delete;
        -:  735:
      577:  736:      ~_RehashStateGuard()
        -:  737:      {
      577:  738:	if (_M_guarded_obj)
    #####:  739:	  _M_guarded_obj->_M_reset(_M_prev_state);
      577:  740:      }
        -:  741:    };
        -:  742:
        -:  743:  // Base classes for std::_Hashtable.  We define these base classes
        -:  744:  // because in some cases we want to do different things depending on
        -:  745:  // the value of a policy class.  In some cases the policy class
        -:  746:  // affects which member functions and nested typedefs are defined;
        -:  747:  // we handle that by specializing base class templates.  Several of
        -:  748:  // the base class templates need to access other members of class
        -:  749:  // template _Hashtable, so we use a variant of the "Curiously
        -:  750:  // Recurring Template Pattern" (CRTP) technique.
        -:  751:
        -:  752:  /**
        -:  753:   *  Primary class template _Map_base.
        -:  754:   *
        -:  755:   *  If the hashtable has a value type of the form pair<const T1, T2> and
        -:  756:   *  a key extraction policy (_ExtractKey) that returns the first part
        -:  757:   *  of the pair, the hashtable gets a mapped_type typedef.  If it
        -:  758:   *  satisfies those criteria and also has unique keys, then it also
        -:  759:   *  gets an operator[].
        -:  760:   */
        -:  761:  template<typename _Key, typename _Value, typename _Alloc,
        -:  762:	   typename _ExtractKey, typename _Equal,
        -:  763:	   typename _Hash, typename _RangeHash, typename _Unused,
        -:  764:	   typename _RehashPolicy, typename _Traits,
        -:  765:	   bool _Unique_keys = _Traits::__unique_keys::value>
        -:  766:    struct _Map_base { };
        -:  767:
        -:  768:  /// Partial specialization, __unique_keys set to false, std::pair value type.
        -:  769:  template<typename _Key, typename _Val, typename _Alloc, typename _Equal,
        -:  770:	   typename _Hash, typename _RangeHash, typename _Unused,
        -:  771:	   typename _RehashPolicy, typename _Traits>
        -:  772:    struct _Map_base<_Key, pair<const _Key, _Val>, _Alloc, _Select1st, _Equal,
        -:  773:		     _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits, false>
        -:  774:    {
        -:  775:      using mapped_type = _Val;
        -:  776:    };
        -:  777:
        -:  778:  /// Partial specialization, __unique_keys set to true.
        -:  779:  template<typename _Key, typename _Val, typename _Alloc, typename _Equal,
        -:  780:	   typename _Hash, typename _RangeHash, typename _Unused,
        -:  781:	   typename _RehashPolicy, typename _Traits>
        -:  782:    struct _Map_base<_Key, pair<const _Key, _Val>, _Alloc, _Select1st, _Equal,
        -:  783:		     _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits, true>
        -:  784:    {
        -:  785:    private:
        -:  786:      using __hashtable_base = _Hashtable_base<_Key, pair<const _Key, _Val>,
        -:  787:					       _Select1st, _Equal, _Hash,
        -:  788:					       _RangeHash, _Unused,
        -:  789:					       _Traits>;
        -:  790:
        -:  791:      using __hashtable = _Hashtable<_Key, pair<const _Key, _Val>, _Alloc,
        -:  792:				     _Select1st, _Equal, _Hash, _RangeHash,
        -:  793:				     _Unused, _RehashPolicy, _Traits>;
        -:  794:
        -:  795:      using __hash_code = typename __hashtable_base::__hash_code;
        -:  796:
        -:  797:    public:
        -:  798:      using key_type = typename __hashtable_base::key_type;
        -:  799:      using mapped_type = _Val;
        -:  800:
        -:  801:      mapped_type&
        -:  802:      operator[](const key_type& __k);
        -:  803:
        -:  804:      mapped_type&
        -:  805:      operator[](key_type&& __k);
        -:  806:
        -:  807:      // _GLIBCXX_RESOLVE_LIB_DEFECTS
        -:  808:      // DR 761. unordered_map needs an at() member function.
        -:  809:      mapped_type&
    #####:  810:      at(const key_type& __k)
        -:  811:      {
    #####:  812:	auto __ite = static_cast<__hashtable*>(this)->find(__k);
    #####:  813:	if (!__ite._M_cur)
    #####:  814:	  __throw_out_of_range(__N("unordered_map::at"));
    #####:  815:	return __ite->second;
        -:  816:      }
        -:  817:
        -:  818:      const mapped_type&
        -:  819:      at(const key_type& __k) const
        -:  820:      {
        -:  821:	auto __ite = static_cast<const __hashtable*>(this)->find(__k);
        -:  822:	if (!__ite._M_cur)
        -:  823:	  __throw_out_of_range(__N("unordered_map::at"));
        -:  824:	return __ite->second;
        -:  825:      }
        -:  826:    };
        -:  827:
        -:  828:  template<typename _Key, typename _Val, typename _Alloc, typename _Equal,
        -:  829:	   typename _Hash, typename _RangeHash, typename _Unused,
        -:  830:	   typename _RehashPolicy, typename _Traits>
        -:  831:    auto
     889*:  832:    _Map_base<_Key, pair<const _Key, _Val>, _Alloc, _Select1st, _Equal,
        -:  833:	      _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits, true>::
        -:  834:    operator[](const key_type& __k)
        -:  835:    -> mapped_type&
        -:  836:    {
     889*:  837:      __hashtable* __h = static_cast<__hashtable*>(this);
     889*:  838:      __hash_code __code = __h->_M_hash_code(__k);
     889*:  839:      std::size_t __bkt = __h->_M_bucket_index(__code);
     889*:  840:      if (auto __node = __h->_M_find_node(__bkt, __k, __code))
     874*:  841:	return __node->_M_v().second;
        -:  842:
     452*:  843:      typename __hashtable::_Scoped_node __node {
        -:  844:	__h,
        -:  845:	std::piecewise_construct,
     452*:  846:	std::tuple<const key_type&>(__k),
    #####:  847:	std::tuple<>()
        -:  848:      };
        -:  849:      auto __pos
     452*:  850:	= __h->_M_insert_unique_node(__bkt, __code, __node._M_node);
     452*:  851:      __node._M_node = nullptr;
     452*:  852:      return __pos->second;
     452*:  853:    }
------------------
_ZNSt8__detail9_Map_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt4pairIKS6_dESaIS9_ENS_10_Select1stESt8equal_toIS6_ESt4hashIS6_ENS_18_Mod_range_hashingENS_20_Default_ranged_hashENS_20_Prime_rehash_policyENS_17_Hashtable_traitsILb1ELb0ELb1EEELb1EEixERS8_:
    #####:  832:    _Map_base<_Key, pair<const _Key, _Val>, _Alloc, _Select1st, _Equal,
        -:  833:	      _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits, true>::
        -:  834:    operator[](const key_type& __k)
        -:  835:    -> mapped_type&
        -:  836:    {
    #####:  837:      __hashtable* __h = static_cast<__hashtable*>(this);
    #####:  838:      __hash_code __code = __h->_M_hash_code(__k);
    #####:  839:      std::size_t __bkt = __h->_M_bucket_index(__code);
    #####:  840:      if (auto __node = __h->_M_find_node(__bkt, __k, __code))
    #####:  841:	return __node->_M_v().second;
        -:  842:
    #####:  843:      typename __hashtable::_Scoped_node __node {
        -:  844:	__h,
        -:  845:	std::piecewise_construct,
    #####:  846:	std::tuple<const key_type&>(__k),
    #####:  847:	std::tuple<>()
        -:  848:      };
        -:  849:      auto __pos
    #####:  850:	= __h->_M_insert_unique_node(__bkt, __code, __node._M_node);
    #####:  851:      __node._M_node = nullptr;
    #####:  852:      return __pos->second;
    #####:  853:    }
------------------
_ZNSt8__detail9_Map_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt4pairIKS6_S6_ESaIS9_ENS_10_Select1stESt8equal_toIS6_ESt4hashIS6_ENS_18_Mod_range_hashingENS_20_Default_ranged_hashENS_20_Prime_rehash_policyENS_17_Hashtable_traitsILb1ELb0ELb1EEELb1EEixERS8_:
       84:  832:    _Map_base<_Key, pair<const _Key, _Val>, _Alloc, _Select1st, _Equal,
        -:  833:	      _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits, true>::
        -:  834:    operator[](const key_type& __k)
        -:  835:    -> mapped_type&
        -:  836:    {
       84:  837:      __hashtable* __h = static_cast<__hashtable*>(this);
       84:  838:      __hash_code __code = __h->_M_hash_code(__k);
       84:  839:      std::size_t __bkt = __h->_M_bucket_index(__code);
       84:  840:      if (auto __node = __h->_M_find_node(__bkt, __k, __code))
       70:  841:	return __node->_M_v().second;
        -:  842:
       49:  843:      typename __hashtable::_Scoped_node __node {
        -:  844:	__h,
        -:  845:	std::piecewise_construct,
       49:  846:	std::tuple<const key_type&>(__k),
    #####:  847:	std::tuple<>()
        -:  848:      };
        -:  849:      auto __pos
       49:  850:	= __h->_M_insert_unique_node(__bkt, __code, __node._M_node);
       49:  851:      __node._M_node = nullptr;
       49:  852:      return __pos->second;
       49:  853:    }
------------------
_ZNSt8__detail9_Map_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt4pairIKS6_St6vectorIS6_SaIS6_EEESaISC_ENS_10_Select1stESt8equal_toIS6_ESt4hashIS6_ENS_18_Mod_range_hashingENS_20_Default_ranged_hashENS_20_Prime_rehash_policyENS_17_Hashtable_traitsILb1ELb0ELb1EEELb1EEixERS8_:
       95:  832:    _Map_base<_Key, pair<const _Key, _Val>, _Alloc, _Select1st, _Equal,
        -:  833:	      _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits, true>::
        -:  834:    operator[](const key_type& __k)
        -:  835:    -> mapped_type&
        -:  836:    {
       95:  837:      __hashtable* __h = static_cast<__hashtable*>(this);
       95:  838:      __hash_code __code = __h->_M_hash_code(__k);
       95:  839:      std::size_t __bkt = __h->_M_bucket_index(__code);
       95:  840:      if (auto __node = __h->_M_find_node(__bkt, __k, __code))
    #####:  841:	return __node->_M_v().second;
        -:  842:
       95:  843:      typename __hashtable::_Scoped_node __node {
        -:  844:	__h,
        -:  845:	std::piecewise_construct,
       95:  846:	std::tuple<const key_type&>(__k),
    #####:  847:	std::tuple<>()
        -:  848:      };
        -:  849:      auto __pos
       95:  850:	= __h->_M_insert_unique_node(__bkt, __code, __node._M_node);
       95:  851:      __node._M_node = nullptr;
       95:  852:      return __pos->second;
       95:  853:    }
------------------
_ZNSt8__detail9_Map_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt4pairIKS6_iESaIS9_ENS_10_Select1stESt8equal_toIS6_ESt4hashIS6_ENS_18_Mod_range_hashingENS_20_Default_ranged_hashENS_20_Prime_rehash_policyENS_17_Hashtable_traitsILb1ELb0ELb1EEELb1EEixERS8_:
      573:  832:    _Map_base<_Key, pair<const _Key, _Val>, _Alloc, _Select1st, _Equal,
        -:  833:	      _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits, true>::
        -:  834:    operator[](const key_type& __k)
        -:  835:    -> mapped_type&
        -:  836:    {
      573:  837:      __hashtable* __h = static_cast<__hashtable*>(this);
      573:  838:      __hash_code __code = __h->_M_hash_code(__k);
      573:  839:      std::size_t __bkt = __h->_M_bucket_index(__code);
      573:  840:      if (auto __node = __h->_M_find_node(__bkt, __k, __code))
      706:  841:	return __node->_M_v().second;
        -:  842:
      220:  843:      typename __hashtable::_Scoped_node __node {
        -:  844:	__h,
        -:  845:	std::piecewise_construct,
      220:  846:	std::tuple<const key_type&>(__k),
    #####:  847:	std::tuple<>()
        -:  848:      };
        -:  849:      auto __pos
      220:  850:	= __h->_M_insert_unique_node(__bkt, __code, __node._M_node);
      220:  851:      __node._M_node = nullptr;
      220:  852:      return __pos->second;
      220:  853:    }
------------------
_ZNSt8__detail9_Map_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt4pairIKS6_St13unordered_mapIS6_iSt4hashIS6_ESt8equal_toIS6_ESaIS7_IS8_iEEEESaISH_ENS_10_Select1stESD_SB_NS_18_Mod_range_hashingENS_20_Default_ranged_hashENS_20_Prime_rehash_policyENS_17_Hashtable_traitsILb1ELb0ELb1EEELb1EEixERS8_:
      137:  832:    _Map_base<_Key, pair<const _Key, _Val>, _Alloc, _Select1st, _Equal,
        -:  833:	      _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits, true>::
        -:  834:    operator[](const key_type& __k)
        -:  835:    -> mapped_type&
        -:  836:    {
      137:  837:      __hashtable* __h = static_cast<__hashtable*>(this);
      137:  838:      __hash_code __code = __h->_M_hash_code(__k);
      137:  839:      std::size_t __bkt = __h->_M_bucket_index(__code);
      137:  840:      if (auto __node = __h->_M_find_node(__bkt, __k, __code))
       98:  841:	return __node->_M_v().second;
        -:  842:
       88:  843:      typename __hashtable::_Scoped_node __node {
        -:  844:	__h,
        -:  845:	std::piecewise_construct,
       88:  846:	std::tuple<const key_type&>(__k),
    #####:  847:	std::tuple<>()
        -:  848:      };
        -:  849:      auto __pos
       88:  850:	= __h->_M_insert_unique_node(__bkt, __code, __node._M_node);
       88:  851:      __node._M_node = nullptr;
       88:  852:      return __pos->second;
       88:  853:    }
------------------
        -:  854:
        -:  855:  template<typename _Key, typename _Val, typename _Alloc, typename _Equal,
        -:  856:	   typename _Hash, typename _RangeHash, typename _Unused,
        -:  857:	   typename _RehashPolicy, typename _Traits>
        -:  858:    auto
        -:  859:    _Map_base<_Key, pair<const _Key, _Val>, _Alloc, _Select1st, _Equal,
        -:  860:	      _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits, true>::
        -:  861:    operator[](key_type&& __k)
        -:  862:    -> mapped_type&
        -:  863:    {
        -:  864:      __hashtable* __h = static_cast<__hashtable*>(this);
        -:  865:      __hash_code __code = __h->_M_hash_code(__k);
        -:  866:      std::size_t __bkt = __h->_M_bucket_index(__code);
        -:  867:      if (auto __node = __h->_M_find_node(__bkt, __k, __code))
        -:  868:	return __node->_M_v().second;
        -:  869:
        -:  870:      typename __hashtable::_Scoped_node __node {
        -:  871:	__h,
        -:  872:	std::piecewise_construct,
        -:  873:	std::forward_as_tuple(std::move(__k)),
        -:  874:	std::tuple<>()
        -:  875:      };
        -:  876:      auto __pos
        -:  877:	= __h->_M_insert_unique_node(__bkt, __code, __node._M_node);
        -:  878:      __node._M_node = nullptr;
        -:  879:      return __pos->second;
        -:  880:    }
        -:  881:
        -:  882:  // Partial specialization for unordered_map<const T, U>, see PR 104174.
        -:  883:  template<typename _Key, typename _Val, typename _Alloc, typename _Equal,
        -:  884:	   typename _Hash, typename _RangeHash, typename _Unused,
        -:  885:	   typename _RehashPolicy, typename _Traits, bool __uniq>
        -:  886:    struct _Map_base<const _Key, pair<const _Key, _Val>,
        -:  887:		     _Alloc, _Select1st, _Equal, _Hash,
        -:  888:		     _RangeHash, _Unused, _RehashPolicy, _Traits, __uniq>
        -:  889:    : _Map_base<_Key, pair<const _Key, _Val>, _Alloc, _Select1st, _Equal, _Hash,
        -:  890:		_RangeHash, _Unused, _RehashPolicy, _Traits, __uniq>
        -:  891:    { };
        -:  892:
        -:  893:  /**
        -:  894:   *  Primary class template _Insert_base.
        -:  895:   *
        -:  896:   *  Defines @c insert member functions appropriate to all _Hashtables.
        -:  897:   */
        -:  898:  template<typename _Key, typename _Value, typename _Alloc,
        -:  899:	   typename _ExtractKey, typename _Equal,
        -:  900:	   typename _Hash, typename _RangeHash, typename _Unused,
        -:  901:	   typename _RehashPolicy, typename _Traits>
        -:  902:    struct _Insert_base
        -:  903:    {
        -:  904:    protected:
        -:  905:      using __hashtable_base = _Hashtable_base<_Key, _Value, _ExtractKey,
        -:  906:					       _Equal, _Hash, _RangeHash,
        -:  907:					       _Unused, _Traits>;
        -:  908:
        -:  909:      using __hashtable = _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        -:  910:				     _Hash, _RangeHash,
        -:  911:				     _Unused, _RehashPolicy, _Traits>;
        -:  912:
        -:  913:      using __hash_cached = typename _Traits::__hash_cached;
        -:  914:      using __constant_iterators = typename _Traits::__constant_iterators;
        -:  915:
        -:  916:      using __hashtable_alloc = _Hashtable_alloc<
        -:  917:	__alloc_rebind<_Alloc, _Hash_node<_Value,
        -:  918:					  __hash_cached::value>>>;
        -:  919:
        -:  920:      using value_type = typename __hashtable_base::value_type;
        -:  921:      using size_type = typename __hashtable_base::size_type;
        -:  922:
        -:  923:      using __unique_keys = typename _Traits::__unique_keys;
        -:  924:      using __node_alloc_type = typename __hashtable_alloc::__node_alloc_type;
        -:  925:      using __node_gen_type = _AllocNode<__node_alloc_type>;
        -:  926:
        -:  927:      __hashtable&
      227:  928:      _M_conjure_hashtable()
      227:  929:      { return *(static_cast<__hashtable*>(this)); }
        -:  930:
        -:  931:      template<typename _InputIterator, typename _NodeGetter>
        -:  932:	void
        -:  933:	_M_insert_range(_InputIterator __first, _InputIterator __last,
        -:  934:			const _NodeGetter&, true_type __uks);
        -:  935:
        -:  936:      template<typename _InputIterator, typename _NodeGetter>
        -:  937:	void
        -:  938:	_M_insert_range(_InputIterator __first, _InputIterator __last,
        -:  939:			const _NodeGetter&, false_type __uks);
        -:  940:
        -:  941:    public:
        -:  942:      using iterator = _Node_iterator<_Value, __constant_iterators::value,
        -:  943:				      __hash_cached::value>;
        -:  944:
        -:  945:      using const_iterator = _Node_const_iterator<_Value,
        -:  946:						  __constant_iterators::value,
        -:  947:						  __hash_cached::value>;
        -:  948:
        -:  949:      using __ireturn_type = __conditional_t<__unique_keys::value,
        -:  950:					     std::pair<iterator, bool>,
        -:  951:					     iterator>;
        -:  952:
        -:  953:      __ireturn_type
      227:  954:      insert(const value_type& __v)
        -:  955:      {
      227:  956:	__hashtable& __h = _M_conjure_hashtable();
      227:  957:	__node_gen_type __node_gen(__h);
      454:  958:	return __h._M_insert(__v, __node_gen, __unique_keys{});
        -:  959:      }
        -:  960:
        -:  961:      iterator
        -:  962:      insert(const_iterator __hint, const value_type& __v)
        -:  963:      {
        -:  964:	__hashtable& __h = _M_conjure_hashtable();
        -:  965:	__node_gen_type __node_gen(__h);	
        -:  966:	return __h._M_insert(__hint, __v, __node_gen, __unique_keys{});
        -:  967:      }
        -:  968:
        -:  969:      template<typename _KType, typename... _Args>
        -:  970:	std::pair<iterator, bool>
        -:  971:	try_emplace(const_iterator, _KType&& __k, _Args&&... __args)
        -:  972:	{
        -:  973:	  __hashtable& __h = _M_conjure_hashtable();
        -:  974:	  auto __code = __h._M_hash_code(__k);
        -:  975:	  std::size_t __bkt = __h._M_bucket_index(__code);
        -:  976:	  if (auto __node = __h._M_find_node(__bkt, __k, __code))
        -:  977:	    return { iterator(__node), false };
        -:  978:
        -:  979:	  typename __hashtable::_Scoped_node __node {
        -:  980:	    &__h,
        -:  981:	    std::piecewise_construct,
        -:  982:	    std::forward_as_tuple(std::forward<_KType>(__k)),
        -:  983:	    std::forward_as_tuple(std::forward<_Args>(__args)...)
        -:  984:	    };
        -:  985:	  auto __it
        -:  986:	    = __h._M_insert_unique_node(__bkt, __code, __node._M_node);
        -:  987:	  __node._M_node = nullptr;
        -:  988:	  return { __it, true };
        -:  989:	}
        -:  990:
        -:  991:      void
        -:  992:      insert(initializer_list<value_type> __l)
        -:  993:      { this->insert(__l.begin(), __l.end()); }
        -:  994:
        -:  995:      template<typename _InputIterator>
        -:  996:	void
        -:  997:	insert(_InputIterator __first, _InputIterator __last)
        -:  998:	{
        -:  999:	  __hashtable& __h = _M_conjure_hashtable();
        -: 1000:	  __node_gen_type __node_gen(__h);
        -: 1001:	  return _M_insert_range(__first, __last, __node_gen, __unique_keys{});
        -: 1002:	}
        -: 1003:    };
        -: 1004:
        -: 1005:  template<typename _Key, typename _Value, typename _Alloc,
        -: 1006:	   typename _ExtractKey, typename _Equal,
        -: 1007:	   typename _Hash, typename _RangeHash, typename _Unused,
        -: 1008:	   typename _RehashPolicy, typename _Traits>
        -: 1009:    template<typename _InputIterator, typename _NodeGetter>
        -: 1010:      void
        -: 1011:      _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        -: 1012:		   _Hash, _RangeHash, _Unused,
        -: 1013:		   _RehashPolicy, _Traits>::
        -: 1014:      _M_insert_range(_InputIterator __first, _InputIterator __last,
        -: 1015:		      const _NodeGetter& __node_gen, true_type __uks)
        -: 1016:      {
        -: 1017:	__hashtable& __h = _M_conjure_hashtable();
        -: 1018:	for (; __first != __last; ++__first)
        -: 1019:	  __h._M_insert(*__first, __node_gen, __uks);
        -: 1020:      }
        -: 1021:
        -: 1022:  template<typename _Key, typename _Value, typename _Alloc,
        -: 1023:	   typename _ExtractKey, typename _Equal,
        -: 1024:	   typename _Hash, typename _RangeHash, typename _Unused,
        -: 1025:	   typename _RehashPolicy, typename _Traits>
        -: 1026:    template<typename _InputIterator, typename _NodeGetter>
        -: 1027:      void
        -: 1028:      _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        -: 1029:		   _Hash, _RangeHash, _Unused,
        -: 1030:		   _RehashPolicy, _Traits>::
        -: 1031:      _M_insert_range(_InputIterator __first, _InputIterator __last,
        -: 1032:		      const _NodeGetter& __node_gen, false_type __uks)
        -: 1033:      {
        -: 1034:	using __rehash_guard_t = typename __hashtable::__rehash_guard_t;
        -: 1035:	using __pair_type = std::pair<bool, std::size_t>;
        -: 1036:
        -: 1037:	size_type __n_elt = __detail::__distance_fw(__first, __last);
        -: 1038:	if (__n_elt == 0)
        -: 1039:	  return;
        -: 1040:
        -: 1041:	__hashtable& __h = _M_conjure_hashtable();
        -: 1042:	__rehash_guard_t __rehash_guard(__h._M_rehash_policy);
        -: 1043:	__pair_type __do_rehash
        -: 1044:	  = __h._M_rehash_policy._M_need_rehash(__h._M_bucket_count,
        -: 1045:						__h._M_element_count,
        -: 1046:						__n_elt);
        -: 1047:
        -: 1048:	if (__do_rehash.first)
        -: 1049:	  __h._M_rehash(__do_rehash.second, __uks);
        -: 1050:
        -: 1051:	__rehash_guard._M_guarded_obj = nullptr;
        -: 1052:	for (; __first != __last; ++__first)
        -: 1053:	  __h._M_insert(*__first, __node_gen, __uks);
        -: 1054:      }
        -: 1055:
        -: 1056:  /**
        -: 1057:   *  Primary class template _Insert.
        -: 1058:   *
        -: 1059:   *  Defines @c insert member functions that depend on _Hashtable policies,
        -: 1060:   *  via partial specializations.
        -: 1061:   */
        -: 1062:  template<typename _Key, typename _Value, typename _Alloc,
        -: 1063:	   typename _ExtractKey, typename _Equal,
        -: 1064:	   typename _Hash, typename _RangeHash, typename _Unused,
        -: 1065:	   typename _RehashPolicy, typename _Traits,
        -: 1066:	   bool _Constant_iterators = _Traits::__constant_iterators::value>
        -: 1067:    struct _Insert;
        -: 1068:
        -: 1069:  /// Specialization.
        -: 1070:  template<typename _Key, typename _Value, typename _Alloc,
        -: 1071:	   typename _ExtractKey, typename _Equal,
        -: 1072:	   typename _Hash, typename _RangeHash, typename _Unused,
        -: 1073:	   typename _RehashPolicy, typename _Traits>
        -: 1074:    struct _Insert<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        -: 1075:		   _Hash, _RangeHash, _Unused,
        -: 1076:		   _RehashPolicy, _Traits, true>
        -: 1077:    : public _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        -: 1078:			  _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>
        -: 1079:    {
        -: 1080:      using __base_type = _Insert_base<_Key, _Value, _Alloc, _ExtractKey,
        -: 1081:				       _Equal, _Hash, _RangeHash, _Unused,
        -: 1082:				       _RehashPolicy, _Traits>;
        -: 1083:
        -: 1084:      using value_type = typename __base_type::value_type;
        -: 1085:      using iterator = typename __base_type::iterator;
        -: 1086:      using const_iterator =  typename __base_type::const_iterator;
        -: 1087:      using __ireturn_type = typename __base_type::__ireturn_type;
        -: 1088:
        -: 1089:      using __unique_keys = typename __base_type::__unique_keys;
        -: 1090:      using __hashtable = typename __base_type::__hashtable;
        -: 1091:      using __node_gen_type = typename __base_type::__node_gen_type;
        -: 1092:
        -: 1093:      using __base_type::insert;
        -: 1094:
        -: 1095:      __ireturn_type
        -: 1096:      insert(value_type&& __v)
        -: 1097:      {
        -: 1098:	__hashtable& __h = this->_M_conjure_hashtable();
        -: 1099:	__node_gen_type __node_gen(__h);
        -: 1100:	return __h._M_insert(std::move(__v), __node_gen, __unique_keys{});
        -: 1101:      }
        -: 1102:
        -: 1103:      iterator
        -: 1104:      insert(const_iterator __hint, value_type&& __v)
        -: 1105:      {
        -: 1106:	__hashtable& __h = this->_M_conjure_hashtable();
        -: 1107:	__node_gen_type __node_gen(__h);
        -: 1108:	return __h._M_insert(__hint, std::move(__v), __node_gen,
        -: 1109:			     __unique_keys{});
        -: 1110:      }
        -: 1111:    };
        -: 1112:
        -: 1113:  /// Specialization.
        -: 1114:  template<typename _Key, typename _Value, typename _Alloc,
        -: 1115:	   typename _ExtractKey, typename _Equal,
        -: 1116:	   typename _Hash, typename _RangeHash, typename _Unused,
        -: 1117:	   typename _RehashPolicy, typename _Traits>
        -: 1118:    struct _Insert<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        -: 1119:		   _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits, false>
        -: 1120:    : public _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        -: 1121:			  _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits>
        -: 1122:    {
        -: 1123:      using __base_type = _Insert_base<_Key, _Value, _Alloc, _ExtractKey,
        -: 1124:				       _Equal, _Hash, _RangeHash, _Unused,
        -: 1125:				       _RehashPolicy, _Traits>;
        -: 1126:      using value_type = typename __base_type::value_type;
        -: 1127:      using iterator = typename __base_type::iterator;
        -: 1128:      using const_iterator =  typename __base_type::const_iterator;
        -: 1129:
        -: 1130:      using __unique_keys = typename __base_type::__unique_keys;
        -: 1131:      using __hashtable = typename __base_type::__hashtable;
        -: 1132:      using __ireturn_type = typename __base_type::__ireturn_type;
        -: 1133:
        -: 1134:      using __base_type::insert;
        -: 1135:
        -: 1136:      template<typename _Pair>
        -: 1137:	using __is_cons = std::is_constructible<value_type, _Pair&&>;
        -: 1138:
        -: 1139:      template<typename _Pair>
        -: 1140:	using _IFcons = std::enable_if<__is_cons<_Pair>::value>;
        -: 1141:
        -: 1142:      template<typename _Pair>
        -: 1143:	using _IFconsp = typename _IFcons<_Pair>::type;
        -: 1144:
        -: 1145:      template<typename _Pair, typename = _IFconsp<_Pair>>
        -: 1146:	__ireturn_type
        -: 1147:	insert(_Pair&& __v)
        -: 1148:	{
        -: 1149:	  __hashtable& __h = this->_M_conjure_hashtable();
        -: 1150:	  return __h._M_emplace(__unique_keys{}, std::forward<_Pair>(__v));
        -: 1151:	}
        -: 1152:
        -: 1153:      template<typename _Pair, typename = _IFconsp<_Pair>>
        -: 1154:	iterator
        -: 1155:	insert(const_iterator __hint, _Pair&& __v)
        -: 1156:	{
        -: 1157:	  __hashtable& __h = this->_M_conjure_hashtable();
        -: 1158:	  return __h._M_emplace(__hint, __unique_keys{},
        -: 1159:				std::forward<_Pair>(__v));
        -: 1160:	}
        -: 1161:   };
        -: 1162:
        -: 1163:  template<typename _Policy>
        -: 1164:    using __has_load_factor = typename _Policy::__has_load_factor;
        -: 1165:
        -: 1166:  /**
        -: 1167:   *  Primary class template  _Rehash_base.
        -: 1168:   *
        -: 1169:   *  Give hashtable the max_load_factor functions and reserve iff the
        -: 1170:   *  rehash policy supports it.
        -: 1171:  */
        -: 1172:  template<typename _Key, typename _Value, typename _Alloc,
        -: 1173:	   typename _ExtractKey, typename _Equal,
        -: 1174:	   typename _Hash, typename _RangeHash, typename _Unused,
        -: 1175:	   typename _RehashPolicy, typename _Traits,
        -: 1176:	   typename =
        -: 1177:	     __detected_or_t<false_type, __has_load_factor, _RehashPolicy>>
        -: 1178:    struct _Rehash_base;
        -: 1179:
        -: 1180:  /// Specialization when rehash policy doesn't provide load factor management.
        -: 1181:  template<typename _Key, typename _Value, typename _Alloc,
        -: 1182:	   typename _ExtractKey, typename _Equal,
        -: 1183:	   typename _Hash, typename _RangeHash, typename _Unused,
        -: 1184:	   typename _RehashPolicy, typename _Traits>
        -: 1185:    struct _Rehash_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        -: 1186:			_Hash, _RangeHash, _Unused, _RehashPolicy, _Traits,
        -: 1187:			false_type /* Has load factor */>
        -: 1188:    {
        -: 1189:    };
        -: 1190:
        -: 1191:  /// Specialization when rehash policy provide load factor management.
        -: 1192:  template<typename _Key, typename _Value, typename _Alloc,
        -: 1193:	   typename _ExtractKey, typename _Equal,
        -: 1194:	   typename _Hash, typename _RangeHash, typename _Unused,
        -: 1195:	   typename _RehashPolicy, typename _Traits>
        -: 1196:    struct _Rehash_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        -: 1197:			_Hash, _RangeHash, _Unused, _RehashPolicy, _Traits,
        -: 1198:			true_type /* Has load factor */>
        -: 1199:    {
        -: 1200:    private:
        -: 1201:      using __hashtable = _Hashtable<_Key, _Value, _Alloc, _ExtractKey,
        -: 1202:				     _Equal, _Hash, _RangeHash, _Unused,
        -: 1203:				     _RehashPolicy, _Traits>;
        -: 1204:
        -: 1205:    public:
        -: 1206:      float
        -: 1207:      max_load_factor() const noexcept
        -: 1208:      {
        -: 1209:	const __hashtable* __this = static_cast<const __hashtable*>(this);
        -: 1210:	return __this->__rehash_policy().max_load_factor();
        -: 1211:      }
        -: 1212:
        -: 1213:      void
        -: 1214:      max_load_factor(float __z)
        -: 1215:      {
        -: 1216:	__hashtable* __this = static_cast<__hashtable*>(this);
        -: 1217:	__this->__rehash_policy(_RehashPolicy(__z));
        -: 1218:      }
        -: 1219:
        -: 1220:      void
        -: 1221:      reserve(std::size_t __n)
        -: 1222:      {
        -: 1223:	__hashtable* __this = static_cast<__hashtable*>(this);
        -: 1224:	__this->rehash(__this->__rehash_policy()._M_bkt_for_elements(__n));
        -: 1225:      }
        -: 1226:    };
        -: 1227:
        -: 1228:  /**
        -: 1229:   *  Primary class template _Hashtable_ebo_helper.
        -: 1230:   *
        -: 1231:   *  Helper class using EBO when it is not forbidden (the type is not
        -: 1232:   *  final) and when it is worth it (the type is empty.)
        -: 1233:   */
        -: 1234:  template<int _Nm, typename _Tp,
        -: 1235:	   bool __use_ebo = !__is_final(_Tp) && __is_empty(_Tp)>
        -: 1236:    struct _Hashtable_ebo_helper;
        -: 1237:
        -: 1238:  /// Specialization using EBO.
        -: 1239:  template<int _Nm, typename _Tp>
        -: 1240:    struct _Hashtable_ebo_helper<_Nm, _Tp, true>
        -: 1241:    : private _Tp
        -: 1242:    {
     549*: 1243:      _Hashtable_ebo_helper() noexcept(noexcept(_Tp())) : _Tp() { }
------------------
_ZNSt8__detail21_Hashtable_ebo_helperILi0ESaINS_10_Hash_nodeISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEdELb1EEEELb1EEC2Ev:
    #####: 1243:      _Hashtable_ebo_helper() noexcept(noexcept(_Tp())) : _Tp() { }
------------------
_ZNSt8__detail21_Hashtable_ebo_helperILi0ESaINS_10_Hash_nodeISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_ELb1EEEELb1EEC2Ev:
       37: 1243:      _Hashtable_ebo_helper() noexcept(noexcept(_Tp())) : _Tp() { }
------------------
_ZNSt8__detail21_Hashtable_ebo_helperILi0ESaINS_10_Hash_nodeISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEiELb1EEEELb1EEC2Ev:
      125: 1243:      _Hashtable_ebo_helper() noexcept(noexcept(_Tp())) : _Tp() { }
------------------
_ZNSt8__detail21_Hashtable_ebo_helperILi0ESaINS_10_Hash_nodeINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEELb1EEEELb1EEC2Ev:
        7: 1243:      _Hashtable_ebo_helper() noexcept(noexcept(_Tp())) : _Tp() { }
------------------
_ZNSt8__detail21_Hashtable_ebo_helperILi0ESaINS_10_Hash_nodeISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt6vectorIS8_SaIS8_EEELb1EEEELb1EEC2Ev:
        7: 1243:      _Hashtable_ebo_helper() noexcept(noexcept(_Tp())) : _Tp() { }
------------------
_ZNSt8__detail21_Hashtable_ebo_helperILi0ESaINS_10_Hash_nodeISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt13unordered_mapIS8_iSt4hashIS8_ESt8equal_toIS8_ESaIS2_IS9_iEEEELb1EEEELb1EEC2Ev:
        7: 1243:      _Hashtable_ebo_helper() noexcept(noexcept(_Tp())) : _Tp() { }
------------------
_ZNSt8__detail21_Hashtable_ebo_helperILi0ESt8equal_toINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEELb1EEC2Ev:
      183: 1243:      _Hashtable_ebo_helper() noexcept(noexcept(_Tp())) : _Tp() { }
------------------
_ZNSt8__detail21_Hashtable_ebo_helperILi1ESt4hashINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEELb1EEC2Ev:
      183: 1243:      _Hashtable_ebo_helper() noexcept(noexcept(_Tp())) : _Tp() { }
------------------
        -: 1244:
        -: 1245:      template<typename _OtherTp>
    #####: 1246:	_Hashtable_ebo_helper(_OtherTp&& __tp)
    #####: 1247:	: _Tp(std::forward<_OtherTp>(__tp))
    #####: 1248:	{ }
        -: 1249:
     2040: 1250:      const _Tp& _M_cget() const { return static_cast<const _Tp&>(*this); }
------------------
_ZNKSt8__detail21_Hashtable_ebo_helperILi0ESt8equal_toINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEELb1EE7_M_cgetEv:
     1026: 1250:      const _Tp& _M_cget() const { return static_cast<const _Tp&>(*this); }
------------------
_ZNKSt8__detail21_Hashtable_ebo_helperILi1ESt4hashINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEELb1EE7_M_cgetEv:
     1014: 1250:      const _Tp& _M_cget() const { return static_cast<const _Tp&>(*this); }
------------------
    1826*: 1251:      _Tp& _M_get() { return static_cast<_Tp&>(*this); }
------------------
_ZNSt8__detail21_Hashtable_ebo_helperILi1ESt4hashINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEELb1EE6_M_getEv:
    #####: 1251:      _Tp& _M_get() { return static_cast<_Tp&>(*this); }
------------------
_ZNSt8__detail21_Hashtable_ebo_helperILi0ESaINS_10_Hash_nodeISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_ELb1EEEELb1EE6_M_getEv:
      189: 1251:      _Tp& _M_get() { return static_cast<_Tp&>(*this); }
------------------
_ZNSt8__detail21_Hashtable_ebo_helperILi0ESaINS_10_Hash_nodeISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEiELb1EEEELb1EE6_M_getEv:
      838: 1251:      _Tp& _M_get() { return static_cast<_Tp&>(*this); }
------------------
_ZNSt8__detail21_Hashtable_ebo_helperILi0ESaINS_10_Hash_nodeINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEELb1EEEELb1EE6_M_getEv:
      328: 1251:      _Tp& _M_get() { return static_cast<_Tp&>(*this); }
------------------
_ZNSt8__detail21_Hashtable_ebo_helperILi0ESaINS_10_Hash_nodeISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt6vectorIS8_SaIS8_EEELb1EEEELb1EE6_M_getEv:
      240: 1251:      _Tp& _M_get() { return static_cast<_Tp&>(*this); }
------------------
_ZNSt8__detail21_Hashtable_ebo_helperILi0ESaINS_10_Hash_nodeISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt13unordered_mapIS8_iSt4hashIS8_ESt8equal_toIS8_ESaIS2_IS9_iEEEELb1EEEELb1EE6_M_getEv:
      231: 1251:      _Tp& _M_get() { return static_cast<_Tp&>(*this); }
------------------
_ZNSt8__detail21_Hashtable_ebo_helperILi0ESt8equal_toINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEELb1EE6_M_getEv:
    #####: 1251:      _Tp& _M_get() { return static_cast<_Tp&>(*this); }
------------------
_ZNSt8__detail21_Hashtable_ebo_helperILi0ESaINS_10_Hash_nodeISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEdELb1EEEELb1EE6_M_getEv:
    #####: 1251:      _Tp& _M_get() { return static_cast<_Tp&>(*this); }
------------------
        -: 1252:    };
        -: 1253:
        -: 1254:  /// Specialization not using EBO.
        -: 1255:  template<int _Nm, typename _Tp>
        -: 1256:    struct _Hashtable_ebo_helper<_Nm, _Tp, false>
        -: 1257:    {
        -: 1258:      _Hashtable_ebo_helper() = default;
        -: 1259:
        -: 1260:      template<typename _OtherTp>
        -: 1261:	_Hashtable_ebo_helper(_OtherTp&& __tp)
        -: 1262:	: _M_tp(std::forward<_OtherTp>(__tp))
        -: 1263:	{ }
        -: 1264:
        -: 1265:      const _Tp& _M_cget() const { return _M_tp; }
        -: 1266:      _Tp& _M_get() { return _M_tp; }
        -: 1267:
        -: 1268:    private:
        -: 1269:      _Tp _M_tp{};
        -: 1270:    };
        -: 1271:
        -: 1272:  /**
        -: 1273:   *  Primary class template _Local_iterator_base.
        -: 1274:   *
        -: 1275:   *  Base class for local iterators, used to iterate within a bucket
        -: 1276:   *  but not between buckets.
        -: 1277:   */
        -: 1278:  template<typename _Key, typename _Value, typename _ExtractKey,
        -: 1279:	   typename _Hash, typename _RangeHash, typename _Unused,
        -: 1280:	   bool __cache_hash_code>
        -: 1281:    struct _Local_iterator_base;
        -: 1282:
        -: 1283:  /**
        -: 1284:   *  Primary class template _Hash_code_base.
        -: 1285:   *
        -: 1286:   *  Encapsulates two policy issues that aren't quite orthogonal.
        -: 1287:   *   (1) the difference between using a ranged hash function and using
        -: 1288:   *       the combination of a hash function and a range-hashing function.
        -: 1289:   *       In the former case we don't have such things as hash codes, so
        -: 1290:   *       we have a dummy type as placeholder.
        -: 1291:   *   (2) Whether or not we cache hash codes.  Caching hash codes is
        -: 1292:   *       meaningless if we have a ranged hash function.
        -: 1293:   *
        -: 1294:   *  We also put the key extraction objects here, for convenience.
        -: 1295:   *  Each specialization derives from one or more of the template
        -: 1296:   *  parameters to benefit from Ebo. This is important as this type
        -: 1297:   *  is inherited in some cases by the _Local_iterator_base type used
        -: 1298:   *  to implement local_iterator and const_local_iterator. As with
        -: 1299:   *  any iterator type we prefer to make it as small as possible.
        -: 1300:   */
        -: 1301:  template<typename _Key, typename _Value, typename _ExtractKey,
        -: 1302:	   typename _Hash, typename _RangeHash, typename _Unused,
        -: 1303:	   bool __cache_hash_code>
        -: 1304:    struct _Hash_code_base
        -: 1305:    : private _Hashtable_ebo_helper<1, _Hash>
        -: 1306:    {
        -: 1307:    private:
        -: 1308:      using __ebo_hash = _Hashtable_ebo_helper<1, _Hash>;
        -: 1309:
        -: 1310:      // Gives the local iterator implementation access to _M_bucket_index().
        -: 1311:      friend struct _Local_iterator_base<_Key, _Value, _ExtractKey,
        -: 1312:					 _Hash, _RangeHash, _Unused, false>;
        -: 1313:
        -: 1314:    public:
        -: 1315:      typedef _Hash					hasher;
        -: 1316:
        -: 1317:      hasher
        -: 1318:      hash_function() const
        -: 1319:      { return _M_hash(); }
        -: 1320:
        -: 1321:    protected:
        -: 1322:      typedef std::size_t 				__hash_code;
        -: 1323:
        -: 1324:      // We need the default constructor for the local iterators and _Hashtable
        -: 1325:      // default constructor.
     183*: 1326:      _Hash_code_base() = default;
------------------
_ZNSt8__detail15_Hash_code_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt4pairIKS6_dENS_10_Select1stESt4hashIS6_ENS_18_Mod_range_hashingENS_20_Default_ranged_hashELb1EEC2Ev:
    #####: 1326:      _Hash_code_base() = default;
------------------
_ZNSt8__detail15_Hash_code_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt4pairIKS6_S6_ENS_10_Select1stESt4hashIS6_ENS_18_Mod_range_hashingENS_20_Default_ranged_hashELb1EEC2Ev:
       37: 1326:      _Hash_code_base() = default;
------------------
_ZNSt8__detail15_Hash_code_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt4pairIKS6_iENS_10_Select1stESt4hashIS6_ENS_18_Mod_range_hashingENS_20_Default_ranged_hashELb1EEC2Ev:
      125: 1326:      _Hash_code_base() = default;
------------------
_ZNSt8__detail15_Hash_code_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES6_NS_9_IdentityESt4hashIS6_ENS_18_Mod_range_hashingENS_20_Default_ranged_hashELb1EEC2Ev:
        7: 1326:      _Hash_code_base() = default;
------------------
_ZNSt8__detail15_Hash_code_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt4pairIKS6_St6vectorIS6_SaIS6_EEENS_10_Select1stESt4hashIS6_ENS_18_Mod_range_hashingENS_20_Default_ranged_hashELb1EEC2Ev:
        7: 1326:      _Hash_code_base() = default;
------------------
_ZNSt8__detail15_Hash_code_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt4pairIKS6_St13unordered_mapIS6_iSt4hashIS6_ESt8equal_toIS6_ESaIS7_IS8_iEEEENS_10_Select1stESB_NS_18_Mod_range_hashingENS_20_Default_ranged_hashELb1EEC2Ev:
        7: 1326:      _Hash_code_base() = default;
------------------
        -: 1327:
        -: 1328:      _Hash_code_base(const _Hash& __hash) : __ebo_hash(__hash) { }
        -: 1329:
        -: 1330:      __hash_code
     889*: 1331:      _M_hash_code(const _Key& __k) const
        -: 1332:      {
        -: 1333:	static_assert(__is_invocable<const _Hash&, const _Key&>{},
        -: 1334:	    "hash function must be invocable with an argument of key type");
     889*: 1335:	return _M_hash()(__k);
        -: 1336:      }
------------------
_ZNKSt8__detail15_Hash_code_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES6_NS_9_IdentityESt4hashIS6_ENS_18_Mod_range_hashingENS_20_Default_ranged_hashELb1EE12_M_hash_codeERKS6_:
    #####: 1331:      _M_hash_code(const _Key& __k) const
        -: 1332:      {
        -: 1333:	static_assert(__is_invocable<const _Hash&, const _Key&>{},
        -: 1334:	    "hash function must be invocable with an argument of key type");
    #####: 1335:	return _M_hash()(__k);
        -: 1336:      }
------------------
_ZNKSt8__detail15_Hash_code_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt4pairIKS6_dENS_10_Select1stESt4hashIS6_ENS_18_Mod_range_hashingENS_20_Default_ranged_hashELb1EE12_M_hash_codeERS8_:
    #####: 1331:      _M_hash_code(const _Key& __k) const
        -: 1332:      {
        -: 1333:	static_assert(__is_invocable<const _Hash&, const _Key&>{},
        -: 1334:	    "hash function must be invocable with an argument of key type");
    #####: 1335:	return _M_hash()(__k);
        -: 1336:      }
------------------
_ZNKSt8__detail15_Hash_code_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt4pairIKS6_S6_ENS_10_Select1stESt4hashIS6_ENS_18_Mod_range_hashingENS_20_Default_ranged_hashELb1EE12_M_hash_codeERS8_:
       84: 1331:      _M_hash_code(const _Key& __k) const
        -: 1332:      {
        -: 1333:	static_assert(__is_invocable<const _Hash&, const _Key&>{},
        -: 1334:	    "hash function must be invocable with an argument of key type");
       84: 1335:	return _M_hash()(__k);
        -: 1336:      }
------------------
_ZNKSt8__detail15_Hash_code_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt4pairIKS6_St6vectorIS6_SaIS6_EEENS_10_Select1stESt4hashIS6_ENS_18_Mod_range_hashingENS_20_Default_ranged_hashELb1EE12_M_hash_codeERS8_:
       95: 1331:      _M_hash_code(const _Key& __k) const
        -: 1332:      {
        -: 1333:	static_assert(__is_invocable<const _Hash&, const _Key&>{},
        -: 1334:	    "hash function must be invocable with an argument of key type");
       95: 1335:	return _M_hash()(__k);
        -: 1336:      }
------------------
_ZNKSt8__detail15_Hash_code_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt4pairIKS6_iENS_10_Select1stESt4hashIS6_ENS_18_Mod_range_hashingENS_20_Default_ranged_hashELb1EE12_M_hash_codeERS8_:
      573: 1331:      _M_hash_code(const _Key& __k) const
        -: 1332:      {
        -: 1333:	static_assert(__is_invocable<const _Hash&, const _Key&>{},
        -: 1334:	    "hash function must be invocable with an argument of key type");
      573: 1335:	return _M_hash()(__k);
        -: 1336:      }
------------------
_ZNKSt8__detail15_Hash_code_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt4pairIKS6_St13unordered_mapIS6_iSt4hashIS6_ESt8equal_toIS6_ESaIS7_IS8_iEEEENS_10_Select1stESB_NS_18_Mod_range_hashingENS_20_Default_ranged_hashELb1EE12_M_hash_codeERS8_:
      137: 1331:      _M_hash_code(const _Key& __k) const
        -: 1332:      {
        -: 1333:	static_assert(__is_invocable<const _Hash&, const _Key&>{},
        -: 1334:	    "hash function must be invocable with an argument of key type");
      137: 1335:	return _M_hash()(__k);
        -: 1336:      }
------------------
        -: 1337:
        -: 1338:      template<typename _Kt>
        -: 1339:	__hash_code
      125: 1340:	_M_hash_code_tr(const _Kt& __k) const
        -: 1341:	{
        -: 1342:	  static_assert(__is_invocable<const _Hash&, const _Kt&>{},
        -: 1343:	    "hash function must be invocable with an argument of key type");
      125: 1344:	  return _M_hash()(__k);
        -: 1345:	}
        -: 1346:
        -: 1347:      __hash_code
        -: 1348:      _M_hash_code(const _Hash_node_value<_Value, false>& __n) const
        -: 1349:      { return _M_hash_code(_ExtractKey{}(__n._M_v())); }
        -: 1350:
        -: 1351:      __hash_code
        -: 1352:      _M_hash_code(const _Hash_node_value<_Value, true>& __n) const
        -: 1353:      { return __n._M_hash_code; }
        -: 1354:
        -: 1355:      std::size_t
    1181*: 1356:      _M_bucket_index(__hash_code __c, std::size_t __bkt_count) const
    1181*: 1357:      { return _RangeHash{}(__c, __bkt_count); }
------------------
_ZNKSt8__detail15_Hash_code_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES6_NS_9_IdentityESt4hashIS6_ENS_18_Mod_range_hashingENS_20_Default_ranged_hashELb1EE15_M_bucket_indexEyy:
      132: 1356:      _M_bucket_index(__hash_code __c, std::size_t __bkt_count) const
      132: 1357:      { return _RangeHash{}(__c, __bkt_count); }
------------------
_ZNKSt8__detail15_Hash_code_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt4pairIKS6_dENS_10_Select1stESt4hashIS6_ENS_18_Mod_range_hashingENS_20_Default_ranged_hashELb1EE15_M_bucket_indexEyy:
    #####: 1356:      _M_bucket_index(__hash_code __c, std::size_t __bkt_count) const
    #####: 1357:      { return _RangeHash{}(__c, __bkt_count); }
------------------
_ZNKSt8__detail15_Hash_code_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt4pairIKS6_S6_ENS_10_Select1stESt4hashIS6_ENS_18_Mod_range_hashingENS_20_Default_ranged_hashELb1EE15_M_bucket_indexEyy:
      105: 1356:      _M_bucket_index(__hash_code __c, std::size_t __bkt_count) const
      105: 1357:      { return _RangeHash{}(__c, __bkt_count); }
------------------
_ZNKSt8__detail15_Hash_code_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt4pairIKS6_St6vectorIS6_SaIS6_EEENS_10_Select1stESt4hashIS6_ENS_18_Mod_range_hashingENS_20_Default_ranged_hashELb1EE15_M_bucket_indexEyy:
      102: 1356:      _M_bucket_index(__hash_code __c, std::size_t __bkt_count) const
      102: 1357:      { return _RangeHash{}(__c, __bkt_count); }
------------------
_ZNKSt8__detail15_Hash_code_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt4pairIKS6_iENS_10_Select1stESt4hashIS6_ENS_18_Mod_range_hashingENS_20_Default_ranged_hashELb1EE15_M_bucket_indexEyy:
      698: 1356:      _M_bucket_index(__hash_code __c, std::size_t __bkt_count) const
      698: 1357:      { return _RangeHash{}(__c, __bkt_count); }
------------------
_ZNKSt8__detail15_Hash_code_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt4pairIKS6_St13unordered_mapIS6_iSt4hashIS6_ESt8equal_toIS6_ESaIS7_IS8_iEEEENS_10_Select1stESB_NS_18_Mod_range_hashingENS_20_Default_ranged_hashELb1EE15_M_bucket_indexEyy:
      144: 1356:      _M_bucket_index(__hash_code __c, std::size_t __bkt_count) const
      144: 1357:      { return _RangeHash{}(__c, __bkt_count); }
------------------
        -: 1358:
        -: 1359:      std::size_t
        -: 1360:      _M_bucket_index(const _Hash_node_value<_Value, false>& __n,
        -: 1361:		      std::size_t __bkt_count) const
        -: 1362:	noexcept( noexcept(declval<const _Hash&>()(declval<const _Key&>()))
        -: 1363:		  && noexcept(declval<const _RangeHash&>()((__hash_code)0,
        -: 1364:							   (std::size_t)0)) )
        -: 1365:      {
        -: 1366:	return _RangeHash{}(_M_hash_code(_ExtractKey{}(__n._M_v())),
        -: 1367:			    __bkt_count);
        -: 1368:      }
        -: 1369:
        -: 1370:      std::size_t
     376*: 1371:      _M_bucket_index(const _Hash_node_value<_Value, true>& __n,
        -: 1372:		      std::size_t __bkt_count) const
        -: 1373:	noexcept( noexcept(declval<const _RangeHash&>()((__hash_code)0,
        -: 1374:							(std::size_t)0)) )
     376*: 1375:      { return _RangeHash{}(__n._M_hash_code, __bkt_count); }
------------------
_ZNKSt8__detail15_Hash_code_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES6_NS_9_IdentityESt4hashIS6_ENS_18_Mod_range_hashingENS_20_Default_ranged_hashELb1EE15_M_bucket_indexERKNS_16_Hash_node_valueIS6_Lb1EEEy:
       74: 1371:      _M_bucket_index(const _Hash_node_value<_Value, true>& __n,
        -: 1372:		      std::size_t __bkt_count) const
        -: 1373:	noexcept( noexcept(declval<const _RangeHash&>()((__hash_code)0,
        -: 1374:							(std::size_t)0)) )
       74: 1375:      { return _RangeHash{}(__n._M_hash_code, __bkt_count); }
------------------
_ZNKSt8__detail15_Hash_code_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt4pairIKS6_dENS_10_Select1stESt4hashIS6_ENS_18_Mod_range_hashingENS_20_Default_ranged_hashELb1EE15_M_bucket_indexERKNS_16_Hash_node_valueIS9_Lb1EEEy:
    #####: 1371:      _M_bucket_index(const _Hash_node_value<_Value, true>& __n,
        -: 1372:		      std::size_t __bkt_count) const
        -: 1373:	noexcept( noexcept(declval<const _RangeHash&>()((__hash_code)0,
        -: 1374:							(std::size_t)0)) )
    #####: 1375:      { return _RangeHash{}(__n._M_hash_code, __bkt_count); }
------------------
_ZNKSt8__detail15_Hash_code_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt4pairIKS6_S6_ENS_10_Select1stESt4hashIS6_ENS_18_Mod_range_hashingENS_20_Default_ranged_hashELb1EE15_M_bucket_indexERKNS_16_Hash_node_valueIS9_Lb1EEEy:
       28: 1371:      _M_bucket_index(const _Hash_node_value<_Value, true>& __n,
        -: 1372:		      std::size_t __bkt_count) const
        -: 1373:	noexcept( noexcept(declval<const _RangeHash&>()((__hash_code)0,
        -: 1374:							(std::size_t)0)) )
       28: 1375:      { return _RangeHash{}(__n._M_hash_code, __bkt_count); }
------------------
_ZNKSt8__detail15_Hash_code_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt4pairIKS6_St6vectorIS6_SaIS6_EEENS_10_Select1stESt4hashIS6_ENS_18_Mod_range_hashingENS_20_Default_ranged_hashELb1EE15_M_bucket_indexERKNS_16_Hash_node_valueISC_Lb1EEEy:
       58: 1371:      _M_bucket_index(const _Hash_node_value<_Value, true>& __n,
        -: 1372:		      std::size_t __bkt_count) const
        -: 1373:	noexcept( noexcept(declval<const _RangeHash&>()((__hash_code)0,
        -: 1374:							(std::size_t)0)) )
       58: 1375:      { return _RangeHash{}(__n._M_hash_code, __bkt_count); }
------------------
_ZNKSt8__detail15_Hash_code_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt4pairIKS6_iENS_10_Select1stESt4hashIS6_ENS_18_Mod_range_hashingENS_20_Default_ranged_hashELb1EE15_M_bucket_indexERKNS_16_Hash_node_valueIS9_Lb1EEEy:
      165: 1371:      _M_bucket_index(const _Hash_node_value<_Value, true>& __n,
        -: 1372:		      std::size_t __bkt_count) const
        -: 1373:	noexcept( noexcept(declval<const _RangeHash&>()((__hash_code)0,
        -: 1374:							(std::size_t)0)) )
      165: 1375:      { return _RangeHash{}(__n._M_hash_code, __bkt_count); }
------------------
_ZNKSt8__detail15_Hash_code_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt4pairIKS6_St13unordered_mapIS6_iSt4hashIS6_ESt8equal_toIS6_ESaIS7_IS8_iEEEENS_10_Select1stESB_NS_18_Mod_range_hashingENS_20_Default_ranged_hashELb1EE15_M_bucket_indexERKNS_16_Hash_node_valueISH_Lb1EEEy:
       51: 1371:      _M_bucket_index(const _Hash_node_value<_Value, true>& __n,
        -: 1372:		      std::size_t __bkt_count) const
        -: 1373:	noexcept( noexcept(declval<const _RangeHash&>()((__hash_code)0,
        -: 1374:							(std::size_t)0)) )
       51: 1375:      { return _RangeHash{}(__n._M_hash_code, __bkt_count); }
------------------
        -: 1376:
        -: 1377:      void
        -: 1378:      _M_store_code(_Hash_node_code_cache<false>&, __hash_code) const
        -: 1379:      { }
        -: 1380:
        -: 1381:      void
        -: 1382:      _M_copy_code(_Hash_node_code_cache<false>&,
        -: 1383:		   const _Hash_node_code_cache<false>&) const
        -: 1384:      { }
        -: 1385:
        -: 1386:      void
     577*: 1387:      _M_store_code(_Hash_node_code_cache<true>& __n, __hash_code __c) const
     577*: 1388:      { __n._M_hash_code = __c; }
------------------
_ZNKSt8__detail15_Hash_code_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES6_NS_9_IdentityESt4hashIS6_ENS_18_Mod_range_hashingENS_20_Default_ranged_hashELb1EE13_M_store_codeERNS_21_Hash_node_code_cacheILb1EEEy:
      125: 1387:      _M_store_code(_Hash_node_code_cache<true>& __n, __hash_code __c) const
      125: 1388:      { __n._M_hash_code = __c; }
------------------
_ZNKSt8__detail15_Hash_code_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt4pairIKS6_dENS_10_Select1stESt4hashIS6_ENS_18_Mod_range_hashingENS_20_Default_ranged_hashELb1EE13_M_store_codeERNS_21_Hash_node_code_cacheILb1EEEy:
    #####: 1387:      _M_store_code(_Hash_node_code_cache<true>& __n, __hash_code __c) const
    #####: 1388:      { __n._M_hash_code = __c; }
------------------
_ZNKSt8__detail15_Hash_code_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt4pairIKS6_S6_ENS_10_Select1stESt4hashIS6_ENS_18_Mod_range_hashingENS_20_Default_ranged_hashELb1EE13_M_store_codeERNS_21_Hash_node_code_cacheILb1EEEy:
       49: 1387:      _M_store_code(_Hash_node_code_cache<true>& __n, __hash_code __c) const
       49: 1388:      { __n._M_hash_code = __c; }
------------------
_ZNKSt8__detail15_Hash_code_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt4pairIKS6_St6vectorIS6_SaIS6_EEENS_10_Select1stESt4hashIS6_ENS_18_Mod_range_hashingENS_20_Default_ranged_hashELb1EE13_M_store_codeERNS_21_Hash_node_code_cacheILb1EEEy:
       95: 1387:      _M_store_code(_Hash_node_code_cache<true>& __n, __hash_code __c) const
       95: 1388:      { __n._M_hash_code = __c; }
------------------
_ZNKSt8__detail15_Hash_code_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt4pairIKS6_iENS_10_Select1stESt4hashIS6_ENS_18_Mod_range_hashingENS_20_Default_ranged_hashELb1EE13_M_store_codeERNS_21_Hash_node_code_cacheILb1EEEy:
      220: 1387:      _M_store_code(_Hash_node_code_cache<true>& __n, __hash_code __c) const
      220: 1388:      { __n._M_hash_code = __c; }
------------------
_ZNKSt8__detail15_Hash_code_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt4pairIKS6_St13unordered_mapIS6_iSt4hashIS6_ESt8equal_toIS6_ESaIS7_IS8_iEEEENS_10_Select1stESB_NS_18_Mod_range_hashingENS_20_Default_ranged_hashELb1EE13_M_store_codeERNS_21_Hash_node_code_cacheILb1EEEy:
       88: 1387:      _M_store_code(_Hash_node_code_cache<true>& __n, __hash_code __c) const
       88: 1388:      { __n._M_hash_code = __c; }
------------------
        -: 1389:
        -: 1390:      void
        -: 1391:      _M_copy_code(_Hash_node_code_cache<true>& __to,
        -: 1392:		   const _Hash_node_code_cache<true>& __from) const
        -: 1393:      { __to._M_hash_code = __from._M_hash_code; }
        -: 1394:
        -: 1395:      void
    #####: 1396:      _M_swap(_Hash_code_base& __x)
    #####: 1397:      { std::swap(__ebo_hash::_M_get(), __x.__ebo_hash::_M_get()); }
        -: 1398:
        -: 1399:      const _Hash&
    1014*: 1400:      _M_hash() const { return __ebo_hash::_M_cget(); }
------------------
_ZNKSt8__detail15_Hash_code_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES6_NS_9_IdentityESt4hashIS6_ENS_18_Mod_range_hashingENS_20_Default_ranged_hashELb1EE7_M_hashEv:
      125: 1400:      _M_hash() const { return __ebo_hash::_M_cget(); }
------------------
_ZNKSt8__detail15_Hash_code_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt4pairIKS6_dENS_10_Select1stESt4hashIS6_ENS_18_Mod_range_hashingENS_20_Default_ranged_hashELb1EE7_M_hashEv:
    #####: 1400:      _M_hash() const { return __ebo_hash::_M_cget(); }
------------------
_ZNKSt8__detail15_Hash_code_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt4pairIKS6_S6_ENS_10_Select1stESt4hashIS6_ENS_18_Mod_range_hashingENS_20_Default_ranged_hashELb1EE7_M_hashEv:
       84: 1400:      _M_hash() const { return __ebo_hash::_M_cget(); }
------------------
_ZNKSt8__detail15_Hash_code_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt4pairIKS6_St6vectorIS6_SaIS6_EEENS_10_Select1stESt4hashIS6_ENS_18_Mod_range_hashingENS_20_Default_ranged_hashELb1EE7_M_hashEv:
       95: 1400:      _M_hash() const { return __ebo_hash::_M_cget(); }
------------------
_ZNKSt8__detail15_Hash_code_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt4pairIKS6_iENS_10_Select1stESt4hashIS6_ENS_18_Mod_range_hashingENS_20_Default_ranged_hashELb1EE7_M_hashEv:
      573: 1400:      _M_hash() const { return __ebo_hash::_M_cget(); }
------------------
_ZNKSt8__detail15_Hash_code_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt4pairIKS6_St13unordered_mapIS6_iSt4hashIS6_ESt8equal_toIS6_ESaIS7_IS8_iEEEENS_10_Select1stESB_NS_18_Mod_range_hashingENS_20_Default_ranged_hashELb1EE7_M_hashEv:
      137: 1400:      _M_hash() const { return __ebo_hash::_M_cget(); }
------------------
        -: 1401:    };
        -: 1402:
        -: 1403:  /// Partial specialization used when nodes contain a cached hash code.
        -: 1404:  template<typename _Key, typename _Value, typename _ExtractKey,
        -: 1405:	   typename _Hash, typename _RangeHash, typename _Unused>
        -: 1406:    struct _Local_iterator_base<_Key, _Value, _ExtractKey,
        -: 1407:				_Hash, _RangeHash, _Unused, true>
        -: 1408:    : public _Node_iterator_base<_Value, true>
        -: 1409:    {
        -: 1410:    protected:
        -: 1411:      using __base_node_iter = _Node_iterator_base<_Value, true>;
        -: 1412:      using __hash_code_base = _Hash_code_base<_Key, _Value, _ExtractKey,
        -: 1413:					      _Hash, _RangeHash, _Unused, true>;
        -: 1414:
        -: 1415:      _Local_iterator_base() = default;
        -: 1416:      _Local_iterator_base(const __hash_code_base&,
        -: 1417:			   _Hash_node<_Value, true>* __p,
        -: 1418:			   std::size_t __bkt, std::size_t __bkt_count)
        -: 1419:      : __base_node_iter(__p), _M_bucket(__bkt), _M_bucket_count(__bkt_count)
        -: 1420:      { }
        -: 1421:
        -: 1422:      void
        -: 1423:      _M_incr()
        -: 1424:      {
        -: 1425:	__base_node_iter::_M_incr();
        -: 1426:	if (this->_M_cur)
        -: 1427:	  {
        -: 1428:	    std::size_t __bkt
        -: 1429:	      = _RangeHash{}(this->_M_cur->_M_hash_code, _M_bucket_count);
        -: 1430:	    if (__bkt != _M_bucket)
        -: 1431:	      this->_M_cur = nullptr;
        -: 1432:	  }
        -: 1433:      }
        -: 1434:
        -: 1435:      std::size_t _M_bucket;
        -: 1436:      std::size_t _M_bucket_count;
        -: 1437:
        -: 1438:    public:
        -: 1439:      std::size_t
        -: 1440:      _M_get_bucket() const { return _M_bucket; }  // for debug mode
        -: 1441:    };
        -: 1442:
        -: 1443:  // Uninitialized storage for a _Hash_code_base.
        -: 1444:  // This type is DefaultConstructible and Assignable even if the
        -: 1445:  // _Hash_code_base type isn't, so that _Local_iterator_base<..., false>
        -: 1446:  // can be DefaultConstructible and Assignable.
        -: 1447:  template<typename _Tp, bool _IsEmpty = std::is_empty<_Tp>::value>
        -: 1448:    struct _Hash_code_storage
        -: 1449:    {
        -: 1450:      __gnu_cxx::__aligned_buffer<_Tp> _M_storage;
        -: 1451:
        -: 1452:      _Tp*
        -: 1453:      _M_h() { return _M_storage._M_ptr(); }
        -: 1454:
        -: 1455:      const _Tp*
        -: 1456:      _M_h() const { return _M_storage._M_ptr(); }
        -: 1457:    };
        -: 1458:
        -: 1459:  // Empty partial specialization for empty _Hash_code_base types.
        -: 1460:  template<typename _Tp>
        -: 1461:    struct _Hash_code_storage<_Tp, true>
        -: 1462:    {
        -: 1463:      static_assert( std::is_empty<_Tp>::value, "Type must be empty" );
        -: 1464:
        -: 1465:      // As _Tp is an empty type there will be no bytes written/read through
        -: 1466:      // the cast pointer, so no strict-aliasing violation.
        -: 1467:      _Tp*
        -: 1468:      _M_h() { return reinterpret_cast<_Tp*>(this); }
        -: 1469:
        -: 1470:      const _Tp*
        -: 1471:      _M_h() const { return reinterpret_cast<const _Tp*>(this); }
        -: 1472:    };
        -: 1473:
        -: 1474:  template<typename _Key, typename _Value, typename _ExtractKey,
        -: 1475:	   typename _Hash, typename _RangeHash, typename _Unused>
        -: 1476:    using __hash_code_for_local_iter
        -: 1477:      = _Hash_code_storage<_Hash_code_base<_Key, _Value, _ExtractKey,
        -: 1478:					   _Hash, _RangeHash, _Unused, false>>;
        -: 1479:
        -: 1480:  // Partial specialization used when hash codes are not cached
        -: 1481:  template<typename _Key, typename _Value, typename _ExtractKey,
        -: 1482:	   typename _Hash, typename _RangeHash, typename _Unused>
        -: 1483:    struct _Local_iterator_base<_Key, _Value, _ExtractKey,
        -: 1484:				_Hash, _RangeHash, _Unused, false>
        -: 1485:    : __hash_code_for_local_iter<_Key, _Value, _ExtractKey, _Hash, _RangeHash,
        -: 1486:				 _Unused>
        -: 1487:    , _Node_iterator_base<_Value, false>
        -: 1488:    {
        -: 1489:    protected:
        -: 1490:      using __hash_code_base = _Hash_code_base<_Key, _Value, _ExtractKey,
        -: 1491:					     _Hash, _RangeHash, _Unused, false>;
        -: 1492:      using __node_iter_base = _Node_iterator_base<_Value, false>;
        -: 1493:
        -: 1494:      _Local_iterator_base() : _M_bucket_count(-1) { }
        -: 1495:
        -: 1496:      _Local_iterator_base(const __hash_code_base& __base,
        -: 1497:			   _Hash_node<_Value, false>* __p,
        -: 1498:			   std::size_t __bkt, std::size_t __bkt_count)
        -: 1499:      : __node_iter_base(__p), _M_bucket(__bkt), _M_bucket_count(__bkt_count)
        -: 1500:      { _M_init(__base); }
        -: 1501:
        -: 1502:      ~_Local_iterator_base()
        -: 1503:      {
        -: 1504:	if (_M_bucket_count != size_t(-1))
        -: 1505:	  _M_destroy();
        -: 1506:      }
        -: 1507:
        -: 1508:      _Local_iterator_base(const _Local_iterator_base& __iter)
        -: 1509:      : __node_iter_base(__iter._M_cur), _M_bucket(__iter._M_bucket)
        -: 1510:      , _M_bucket_count(__iter._M_bucket_count)
        -: 1511:      {
        -: 1512:	if (_M_bucket_count != size_t(-1))
        -: 1513:	  _M_init(*__iter._M_h());
        -: 1514:      }
        -: 1515:
        -: 1516:      _Local_iterator_base&
        -: 1517:      operator=(const _Local_iterator_base& __iter)
        -: 1518:      {
        -: 1519:	if (_M_bucket_count != -1)
        -: 1520:	  _M_destroy();
        -: 1521:	this->_M_cur = __iter._M_cur;
        -: 1522:	_M_bucket = __iter._M_bucket;
        -: 1523:	_M_bucket_count = __iter._M_bucket_count;
        -: 1524:	if (_M_bucket_count != -1)
        -: 1525:	  _M_init(*__iter._M_h());
        -: 1526:	return *this;
        -: 1527:      }
        -: 1528:
        -: 1529:      void
        -: 1530:      _M_incr()
        -: 1531:      {
        -: 1532:	__node_iter_base::_M_incr();
        -: 1533:	if (this->_M_cur)
        -: 1534:	  {
        -: 1535:	    std::size_t __bkt = this->_M_h()->_M_bucket_index(*this->_M_cur,
        -: 1536:							      _M_bucket_count);
        -: 1537:	    if (__bkt != _M_bucket)
        -: 1538:	      this->_M_cur = nullptr;
        -: 1539:	  }
        -: 1540:      }
        -: 1541:
        -: 1542:      std::size_t _M_bucket;
        -: 1543:      std::size_t _M_bucket_count;
        -: 1544:
        -: 1545:      void
        -: 1546:      _M_init(const __hash_code_base& __base)
        -: 1547:      { ::new(this->_M_h()) __hash_code_base(__base); }
        -: 1548:
        -: 1549:      void
        -: 1550:      _M_destroy() { this->_M_h()->~__hash_code_base(); }
        -: 1551:
        -: 1552:    public:
        -: 1553:      std::size_t
        -: 1554:      _M_get_bucket() const { return _M_bucket; }  // for debug mode
        -: 1555:    };
        -: 1556:
        -: 1557:  /// local iterators
        -: 1558:  template<typename _Key, typename _Value, typename _ExtractKey,
        -: 1559:	   typename _Hash, typename _RangeHash, typename _Unused,
        -: 1560:	   bool __constant_iterators, bool __cache>
        -: 1561:    struct _Local_iterator
        -: 1562:    : public _Local_iterator_base<_Key, _Value, _ExtractKey,
        -: 1563:				  _Hash, _RangeHash, _Unused, __cache>
        -: 1564:    {
        -: 1565:    private:
        -: 1566:      using __base_type = _Local_iterator_base<_Key, _Value, _ExtractKey,
        -: 1567:					   _Hash, _RangeHash, _Unused, __cache>;
        -: 1568:      using __hash_code_base = typename __base_type::__hash_code_base;
        -: 1569:
        -: 1570:    public:
        -: 1571:      using value_type = _Value;
        -: 1572:      using pointer = __conditional_t<__constant_iterators,
        -: 1573:				      const value_type*, value_type*>;
        -: 1574:      using reference = __conditional_t<__constant_iterators,
        -: 1575:					const value_type&, value_type&>;
        -: 1576:      using difference_type = ptrdiff_t;
        -: 1577:      using iterator_category = forward_iterator_tag;
        -: 1578:
        -: 1579:      _Local_iterator() = default;
        -: 1580:
        -: 1581:      _Local_iterator(const __hash_code_base& __base,
        -: 1582:		      _Hash_node<_Value, __cache>* __n,
        -: 1583:		      std::size_t __bkt, std::size_t __bkt_count)
        -: 1584:      : __base_type(__base, __n, __bkt, __bkt_count)
        -: 1585:      { }
        -: 1586:
        -: 1587:      reference
        -: 1588:      operator*() const
        -: 1589:      { return this->_M_cur->_M_v(); }
        -: 1590:
        -: 1591:      pointer
        -: 1592:      operator->() const
        -: 1593:      { return this->_M_cur->_M_valptr(); }
        -: 1594:
        -: 1595:      _Local_iterator&
        -: 1596:      operator++()
        -: 1597:      {
        -: 1598:	this->_M_incr();
        -: 1599:	return *this;
        -: 1600:      }
        -: 1601:
        -: 1602:      _Local_iterator
        -: 1603:      operator++(int)
        -: 1604:      {
        -: 1605:	_Local_iterator __tmp(*this);
        -: 1606:	this->_M_incr();
        -: 1607:	return __tmp;
        -: 1608:      }
        -: 1609:    };
        -: 1610:
        -: 1611:  /// local const_iterators
        -: 1612:  template<typename _Key, typename _Value, typename _ExtractKey,
        -: 1613:	   typename _Hash, typename _RangeHash, typename _Unused,
        -: 1614:	   bool __constant_iterators, bool __cache>
        -: 1615:    struct _Local_const_iterator
        -: 1616:    : public _Local_iterator_base<_Key, _Value, _ExtractKey,
        -: 1617:				  _Hash, _RangeHash, _Unused, __cache>
        -: 1618:    {
        -: 1619:    private:
        -: 1620:      using __base_type = _Local_iterator_base<_Key, _Value, _ExtractKey,
        -: 1621:					   _Hash, _RangeHash, _Unused, __cache>;
        -: 1622:      using __hash_code_base = typename __base_type::__hash_code_base;
        -: 1623:
        -: 1624:    public:
        -: 1625:      typedef _Value					value_type;
        -: 1626:      typedef const value_type*				pointer;
        -: 1627:      typedef const value_type&				reference;
        -: 1628:      typedef std::ptrdiff_t				difference_type;
        -: 1629:      typedef std::forward_iterator_tag			iterator_category;
        -: 1630:
        -: 1631:      _Local_const_iterator() = default;
        -: 1632:
        -: 1633:      _Local_const_iterator(const __hash_code_base& __base,
        -: 1634:			    _Hash_node<_Value, __cache>* __n,
        -: 1635:			    std::size_t __bkt, std::size_t __bkt_count)
        -: 1636:      : __base_type(__base, __n, __bkt, __bkt_count)
        -: 1637:      { }
        -: 1638:
        -: 1639:      _Local_const_iterator(const _Local_iterator<_Key, _Value, _ExtractKey,
        -: 1640:						  _Hash, _RangeHash, _Unused,
        -: 1641:						  __constant_iterators,
        -: 1642:						  __cache>& __x)
        -: 1643:      : __base_type(__x)
        -: 1644:      { }
        -: 1645:
        -: 1646:      reference
        -: 1647:      operator*() const
        -: 1648:      { return this->_M_cur->_M_v(); }
        -: 1649:
        -: 1650:      pointer
        -: 1651:      operator->() const
        -: 1652:      { return this->_M_cur->_M_valptr(); }
        -: 1653:
        -: 1654:      _Local_const_iterator&
        -: 1655:      operator++()
        -: 1656:      {
        -: 1657:	this->_M_incr();
        -: 1658:	return *this;
        -: 1659:      }
        -: 1660:
        -: 1661:      _Local_const_iterator
        -: 1662:      operator++(int)
        -: 1663:      {
        -: 1664:	_Local_const_iterator __tmp(*this);
        -: 1665:	this->_M_incr();
        -: 1666:	return __tmp;
        -: 1667:      }
        -: 1668:    };
        -: 1669:
        -: 1670:  /**
        -: 1671:   *  Primary class template _Hashtable_base.
        -: 1672:   *
        -: 1673:   *  Helper class adding management of _Equal functor to
        -: 1674:   *  _Hash_code_base type.
        -: 1675:   *
        -: 1676:   *  Base class templates are:
        -: 1677:   *    - __detail::_Hash_code_base
        -: 1678:   *    - __detail::_Hashtable_ebo_helper
        -: 1679:   */
        -: 1680:  template<typename _Key, typename _Value, typename _ExtractKey,
        -: 1681:	   typename _Equal, typename _Hash, typename _RangeHash,
        -: 1682:	   typename _Unused, typename _Traits>
        -: 1683:    struct _Hashtable_base
        -: 1684:    : public _Hash_code_base<_Key, _Value, _ExtractKey, _Hash, _RangeHash,
        -: 1685:			     _Unused, _Traits::__hash_cached::value>,
        -: 1686:      private _Hashtable_ebo_helper<0, _Equal>
        -: 1687:    {
        -: 1688:    public:
        -: 1689:      typedef _Key					key_type;
        -: 1690:      typedef _Value					value_type;
        -: 1691:      typedef _Equal					key_equal;
        -: 1692:      typedef std::size_t				size_type;
        -: 1693:      typedef std::ptrdiff_t				difference_type;
        -: 1694:
        -: 1695:      using __traits_type = _Traits;
        -: 1696:      using __hash_cached = typename __traits_type::__hash_cached;
        -: 1697:
        -: 1698:      using __hash_code_base = _Hash_code_base<_Key, _Value, _ExtractKey,
        -: 1699:					       _Hash, _RangeHash, _Unused,
        -: 1700:					       __hash_cached::value>;
        -: 1701:
        -: 1702:      using __hash_code = typename __hash_code_base::__hash_code;
        -: 1703:
        -: 1704:    private:
        -: 1705:      using _EqualEBO = _Hashtable_ebo_helper<0, _Equal>;
        -: 1706:
        -: 1707:      static bool
        -: 1708:      _S_equals(__hash_code, const _Hash_node_code_cache<false>&)
        -: 1709:      { return true; }
        -: 1710:
        -: 1711:      static bool
        -: 1712:      _S_node_equals(const _Hash_node_code_cache<false>&,
        -: 1713:		     const _Hash_node_code_cache<false>&)
        -: 1714:      { return true; }
        -: 1715:
        -: 1716:      static bool
     528*: 1717:      _S_equals(__hash_code __c, const _Hash_node_code_cache<true>& __n)
     528*: 1718:      { return __c == __n._M_hash_code; }
------------------
_ZNSt8__detail15_Hashtable_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES6_NS_9_IdentityESt8equal_toIS6_ESt4hashIS6_ENS_18_Mod_range_hashingENS_20_Default_ranged_hashENS_17_Hashtable_traitsILb1ELb1ELb1EEEE9_S_equalsEyRKNS_21_Hash_node_code_cacheILb1EEE:
    #####: 1717:      _S_equals(__hash_code __c, const _Hash_node_code_cache<true>& __n)
    #####: 1718:      { return __c == __n._M_hash_code; }
------------------
_ZNSt8__detail15_Hashtable_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt4pairIKS6_dENS_10_Select1stESt8equal_toIS6_ESt4hashIS6_ENS_18_Mod_range_hashingENS_20_Default_ranged_hashENS_17_Hashtable_traitsILb1ELb0ELb1EEEE9_S_equalsEyRKNS_21_Hash_node_code_cacheILb1EEE:
    #####: 1717:      _S_equals(__hash_code __c, const _Hash_node_code_cache<true>& __n)
    #####: 1718:      { return __c == __n._M_hash_code; }
------------------
_ZNSt8__detail15_Hashtable_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt4pairIKS6_S6_ENS_10_Select1stESt8equal_toIS6_ESt4hashIS6_ENS_18_Mod_range_hashingENS_20_Default_ranged_hashENS_17_Hashtable_traitsILb1ELb0ELb1EEEE9_S_equalsEyRKNS_21_Hash_node_code_cacheILb1EEE:
       35: 1717:      _S_equals(__hash_code __c, const _Hash_node_code_cache<true>& __n)
       35: 1718:      { return __c == __n._M_hash_code; }
------------------
_ZNSt8__detail15_Hashtable_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt4pairIKS6_St6vectorIS6_SaIS6_EEENS_10_Select1stESt8equal_toIS6_ESt4hashIS6_ENS_18_Mod_range_hashingENS_20_Default_ranged_hashENS_17_Hashtable_traitsILb1ELb0ELb1EEEE9_S_equalsEyRKNS_21_Hash_node_code_cacheILb1EEE:
        7: 1717:      _S_equals(__hash_code __c, const _Hash_node_code_cache<true>& __n)
        7: 1718:      { return __c == __n._M_hash_code; }
------------------
_ZNSt8__detail15_Hashtable_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt4pairIKS6_iENS_10_Select1stESt8equal_toIS6_ESt4hashIS6_ENS_18_Mod_range_hashingENS_20_Default_ranged_hashENS_17_Hashtable_traitsILb1ELb0ELb1EEEE9_S_equalsEyRKNS_21_Hash_node_code_cacheILb1EEE:
      437: 1717:      _S_equals(__hash_code __c, const _Hash_node_code_cache<true>& __n)
      437: 1718:      { return __c == __n._M_hash_code; }
------------------
_ZNSt8__detail15_Hashtable_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt4pairIKS6_St13unordered_mapIS6_iSt4hashIS6_ESt8equal_toIS6_ESaIS7_IS8_iEEEENS_10_Select1stESD_SB_NS_18_Mod_range_hashingENS_20_Default_ranged_hashENS_17_Hashtable_traitsILb1ELb0ELb1EEEE9_S_equalsEyRKNS_21_Hash_node_code_cacheILb1EEE:
       49: 1717:      _S_equals(__hash_code __c, const _Hash_node_code_cache<true>& __n)
       49: 1718:      { return __c == __n._M_hash_code; }
------------------
        -: 1719:
        -: 1720:      static bool
        -: 1721:      _S_node_equals(const _Hash_node_code_cache<true>& __lhn,
        -: 1722:		     const _Hash_node_code_cache<true>& __rhn)
        -: 1723:      { return __lhn._M_hash_code == __rhn._M_hash_code; }
        -: 1724:
        -: 1725:    protected:
     183*: 1726:      _Hashtable_base() = default;
------------------
_ZNSt8__detail15_Hashtable_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt4pairIKS6_dENS_10_Select1stESt8equal_toIS6_ESt4hashIS6_ENS_18_Mod_range_hashingENS_20_Default_ranged_hashENS_17_Hashtable_traitsILb1ELb0ELb1EEEEC2Ev:
    #####: 1726:      _Hashtable_base() = default;
------------------
_ZNSt8__detail15_Hashtable_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt4pairIKS6_S6_ENS_10_Select1stESt8equal_toIS6_ESt4hashIS6_ENS_18_Mod_range_hashingENS_20_Default_ranged_hashENS_17_Hashtable_traitsILb1ELb0ELb1EEEEC2Ev:
       37: 1726:      _Hashtable_base() = default;
------------------
_ZNSt8__detail15_Hashtable_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt4pairIKS6_iENS_10_Select1stESt8equal_toIS6_ESt4hashIS6_ENS_18_Mod_range_hashingENS_20_Default_ranged_hashENS_17_Hashtable_traitsILb1ELb0ELb1EEEEC2Ev:
      125: 1726:      _Hashtable_base() = default;
------------------
_ZNSt8__detail15_Hashtable_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES6_NS_9_IdentityESt8equal_toIS6_ESt4hashIS6_ENS_18_Mod_range_hashingENS_20_Default_ranged_hashENS_17_Hashtable_traitsILb1ELb1ELb1EEEEC2Ev:
        7: 1726:      _Hashtable_base() = default;
------------------
_ZNSt8__detail15_Hashtable_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt4pairIKS6_St6vectorIS6_SaIS6_EEENS_10_Select1stESt8equal_toIS6_ESt4hashIS6_ENS_18_Mod_range_hashingENS_20_Default_ranged_hashENS_17_Hashtable_traitsILb1ELb0ELb1EEEEC2Ev:
        7: 1726:      _Hashtable_base() = default;
------------------
_ZNSt8__detail15_Hashtable_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt4pairIKS6_St13unordered_mapIS6_iSt4hashIS6_ESt8equal_toIS6_ESaIS7_IS8_iEEEENS_10_Select1stESD_SB_NS_18_Mod_range_hashingENS_20_Default_ranged_hashENS_17_Hashtable_traitsILb1ELb0ELb1EEEEC2Ev:
        7: 1726:      _Hashtable_base() = default;
------------------
        -: 1727:
        -: 1728:      _Hashtable_base(const _Hash& __hash, const _Equal& __eq)
        -: 1729:      : __hash_code_base(__hash), _EqualEBO(__eq)
        -: 1730:      { }
        -: 1731:
        -: 1732:      bool
     715*: 1733:      _M_key_equals(const _Key& __k,
        -: 1734:		    const _Hash_node_value<_Value,
        -: 1735:					   __hash_cached::value>& __n) const
        -: 1736:      {
        -: 1737:	static_assert(__is_invocable<const _Equal&, const _Key&, const _Key&>{},
        -: 1738:	  "key equality predicate must be invocable with two arguments of "
        -: 1739:	  "key type");
    1430*: 1740:	return _M_eq()(__k, _ExtractKey{}(__n._M_v()));
        -: 1741:      }
------------------
_ZNKSt8__detail15_Hashtable_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt4pairIKS6_dENS_10_Select1stESt8equal_toIS6_ESt4hashIS6_ENS_18_Mod_range_hashingENS_20_Default_ranged_hashENS_17_Hashtable_traitsILb1ELb0ELb1EEEE13_M_key_equalsERS8_RKNS_16_Hash_node_valueIS9_Lb1EEE:
    #####: 1733:      _M_key_equals(const _Key& __k,
        -: 1734:		    const _Hash_node_value<_Value,
        -: 1735:					   __hash_cached::value>& __n) const
        -: 1736:      {
        -: 1737:	static_assert(__is_invocable<const _Equal&, const _Key&, const _Key&>{},
        -: 1738:	  "key equality predicate must be invocable with two arguments of "
        -: 1739:	  "key type");
    #####: 1740:	return _M_eq()(__k, _ExtractKey{}(__n._M_v()));
        -: 1741:      }
------------------
_ZNKSt8__detail15_Hashtable_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt4pairIKS6_St6vectorIS6_SaIS6_EEENS_10_Select1stESt8equal_toIS6_ESt4hashIS6_ENS_18_Mod_range_hashingENS_20_Default_ranged_hashENS_17_Hashtable_traitsILb1ELb0ELb1EEEE13_M_key_equalsERS8_RKNS_16_Hash_node_valueISC_Lb1EEE:
    #####: 1733:      _M_key_equals(const _Key& __k,
        -: 1734:		    const _Hash_node_value<_Value,
        -: 1735:					   __hash_cached::value>& __n) const
        -: 1736:      {
        -: 1737:	static_assert(__is_invocable<const _Equal&, const _Key&, const _Key&>{},
        -: 1738:	  "key equality predicate must be invocable with two arguments of "
        -: 1739:	  "key type");
    #####: 1740:	return _M_eq()(__k, _ExtractKey{}(__n._M_v()));
        -: 1741:      }
------------------
_ZNKSt8__detail15_Hashtable_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt4pairIKS6_S6_ENS_10_Select1stESt8equal_toIS6_ESt4hashIS6_ENS_18_Mod_range_hashingENS_20_Default_ranged_hashENS_17_Hashtable_traitsILb1ELb0ELb1EEEE13_M_key_equalsERS8_RKNS_16_Hash_node_valueIS9_Lb1EEE:
      105: 1733:      _M_key_equals(const _Key& __k,
        -: 1734:		    const _Hash_node_value<_Value,
        -: 1735:					   __hash_cached::value>& __n) const
        -: 1736:      {
        -: 1737:	static_assert(__is_invocable<const _Equal&, const _Key&, const _Key&>{},
        -: 1738:	  "key equality predicate must be invocable with two arguments of "
        -: 1739:	  "key type");
      210: 1740:	return _M_eq()(__k, _ExtractKey{}(__n._M_v()));
        -: 1741:      }
------------------
_ZNKSt8__detail15_Hashtable_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt4pairIKS6_iENS_10_Select1stESt8equal_toIS6_ESt4hashIS6_ENS_18_Mod_range_hashingENS_20_Default_ranged_hashENS_17_Hashtable_traitsILb1ELb0ELb1EEEE13_M_key_equalsERS8_RKNS_16_Hash_node_valueIS9_Lb1EEE:
      353: 1733:      _M_key_equals(const _Key& __k,
        -: 1734:		    const _Hash_node_value<_Value,
        -: 1735:					   __hash_cached::value>& __n) const
        -: 1736:      {
        -: 1737:	static_assert(__is_invocable<const _Equal&, const _Key&, const _Key&>{},
        -: 1738:	  "key equality predicate must be invocable with two arguments of "
        -: 1739:	  "key type");
      706: 1740:	return _M_eq()(__k, _ExtractKey{}(__n._M_v()));
        -: 1741:      }
------------------
_ZNKSt8__detail15_Hashtable_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt4pairIKS6_St13unordered_mapIS6_iSt4hashIS6_ESt8equal_toIS6_ESaIS7_IS8_iEEEENS_10_Select1stESD_SB_NS_18_Mod_range_hashingENS_20_Default_ranged_hashENS_17_Hashtable_traitsILb1ELb0ELb1EEEE13_M_key_equalsERS8_RKNS_16_Hash_node_valueISH_Lb1EEE:
       49: 1733:      _M_key_equals(const _Key& __k,
        -: 1734:		    const _Hash_node_value<_Value,
        -: 1735:					   __hash_cached::value>& __n) const
        -: 1736:      {
        -: 1737:	static_assert(__is_invocable<const _Equal&, const _Key&, const _Key&>{},
        -: 1738:	  "key equality predicate must be invocable with two arguments of "
        -: 1739:	  "key type");
       98: 1740:	return _M_eq()(__k, _ExtractKey{}(__n._M_v()));
        -: 1741:      }
------------------
_ZNKSt8__detail15_Hashtable_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES6_NS_9_IdentityESt8equal_toIS6_ESt4hashIS6_ENS_18_Mod_range_hashingENS_20_Default_ranged_hashENS_17_Hashtable_traitsILb1ELb1ELb1EEEE13_M_key_equalsERKS6_RKNS_16_Hash_node_valueIS6_Lb1EEE:
      208: 1733:      _M_key_equals(const _Key& __k,
        -: 1734:		    const _Hash_node_value<_Value,
        -: 1735:					   __hash_cached::value>& __n) const
        -: 1736:      {
        -: 1737:	static_assert(__is_invocable<const _Equal&, const _Key&, const _Key&>{},
        -: 1738:	  "key equality predicate must be invocable with two arguments of "
        -: 1739:	  "key type");
      416: 1740:	return _M_eq()(__k, _ExtractKey{}(__n._M_v()));
        -: 1741:      }
------------------
        -: 1742:
        -: 1743:      template<typename _Kt>
        -: 1744:	bool
      311: 1745:	_M_key_equals_tr(const _Kt& __k,
        -: 1746:			 const _Hash_node_value<_Value,
        -: 1747:					     __hash_cached::value>& __n) const
        -: 1748:	{
        -: 1749:	  static_assert(
        -: 1750:	    __is_invocable<const _Equal&, const _Kt&, const _Key&>{},
        -: 1751:	    "key equality predicate must be invocable with two arguments of "
        -: 1752:	    "key type");
      622: 1753:	  return _M_eq()(__k, _ExtractKey{}(__n._M_v()));
        -: 1754:	}
        -: 1755:
        -: 1756:      bool
     528*: 1757:      _M_equals(const _Key& __k, __hash_code __c,
        -: 1758:		const _Hash_node_value<_Value, __hash_cached::value>& __n) const
     528*: 1759:      { return _S_equals(__c, __n) && _M_key_equals(__k, __n); }
------------------
_ZNKSt8__detail15_Hashtable_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES6_NS_9_IdentityESt8equal_toIS6_ESt4hashIS6_ENS_18_Mod_range_hashingENS_20_Default_ranged_hashENS_17_Hashtable_traitsILb1ELb1ELb1EEEE9_M_equalsERKS6_yRKNS_16_Hash_node_valueIS6_Lb1EEE:
    #####: 1757:      _M_equals(const _Key& __k, __hash_code __c,
        -: 1758:		const _Hash_node_value<_Value, __hash_cached::value>& __n) const
    #####: 1759:      { return _S_equals(__c, __n) && _M_key_equals(__k, __n); }
------------------
_ZNKSt8__detail15_Hashtable_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt4pairIKS6_dENS_10_Select1stESt8equal_toIS6_ESt4hashIS6_ENS_18_Mod_range_hashingENS_20_Default_ranged_hashENS_17_Hashtable_traitsILb1ELb0ELb1EEEE9_M_equalsERS8_yRKNS_16_Hash_node_valueIS9_Lb1EEE:
    #####: 1757:      _M_equals(const _Key& __k, __hash_code __c,
        -: 1758:		const _Hash_node_value<_Value, __hash_cached::value>& __n) const
    #####: 1759:      { return _S_equals(__c, __n) && _M_key_equals(__k, __n); }
------------------
_ZNKSt8__detail15_Hashtable_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt4pairIKS6_S6_ENS_10_Select1stESt8equal_toIS6_ESt4hashIS6_ENS_18_Mod_range_hashingENS_20_Default_ranged_hashENS_17_Hashtable_traitsILb1ELb0ELb1EEEE9_M_equalsERS8_yRKNS_16_Hash_node_valueIS9_Lb1EEE:
       35: 1757:      _M_equals(const _Key& __k, __hash_code __c,
        -: 1758:		const _Hash_node_value<_Value, __hash_cached::value>& __n) const
      35*: 1759:      { return _S_equals(__c, __n) && _M_key_equals(__k, __n); }
------------------
_ZNKSt8__detail15_Hashtable_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt4pairIKS6_St6vectorIS6_SaIS6_EEENS_10_Select1stESt8equal_toIS6_ESt4hashIS6_ENS_18_Mod_range_hashingENS_20_Default_ranged_hashENS_17_Hashtable_traitsILb1ELb0ELb1EEEE9_M_equalsERS8_yRKNS_16_Hash_node_valueISC_Lb1EEE:
        7: 1757:      _M_equals(const _Key& __k, __hash_code __c,
        -: 1758:		const _Hash_node_value<_Value, __hash_cached::value>& __n) const
       7*: 1759:      { return _S_equals(__c, __n) && _M_key_equals(__k, __n); }
------------------
_ZNKSt8__detail15_Hashtable_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt4pairIKS6_iENS_10_Select1stESt8equal_toIS6_ESt4hashIS6_ENS_18_Mod_range_hashingENS_20_Default_ranged_hashENS_17_Hashtable_traitsILb1ELb0ELb1EEEE9_M_equalsERS8_yRKNS_16_Hash_node_valueIS9_Lb1EEE:
      437: 1757:      _M_equals(const _Key& __k, __hash_code __c,
        -: 1758:		const _Hash_node_value<_Value, __hash_cached::value>& __n) const
      437: 1759:      { return _S_equals(__c, __n) && _M_key_equals(__k, __n); }
------------------
_ZNKSt8__detail15_Hashtable_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt4pairIKS6_St13unordered_mapIS6_iSt4hashIS6_ESt8equal_toIS6_ESaIS7_IS8_iEEEENS_10_Select1stESD_SB_NS_18_Mod_range_hashingENS_20_Default_ranged_hashENS_17_Hashtable_traitsILb1ELb0ELb1EEEE9_M_equalsERS8_yRKNS_16_Hash_node_valueISH_Lb1EEE:
       49: 1757:      _M_equals(const _Key& __k, __hash_code __c,
        -: 1758:		const _Hash_node_value<_Value, __hash_cached::value>& __n) const
      49*: 1759:      { return _S_equals(__c, __n) && _M_key_equals(__k, __n); }
------------------
        -: 1760:
        -: 1761:      template<typename _Kt>
        -: 1762:	bool
    #####: 1763:	_M_equals_tr(const _Kt& __k, __hash_code __c,
        -: 1764:		     const _Hash_node_value<_Value,
        -: 1765:					    __hash_cached::value>& __n) const
    #####: 1766:	{ return _S_equals(__c, __n) && _M_key_equals_tr(__k, __n); }
        -: 1767:
        -: 1768:      bool
        -: 1769:      _M_node_equals(
        -: 1770:	const _Hash_node_value<_Value, __hash_cached::value>& __lhn,
        -: 1771:	const _Hash_node_value<_Value, __hash_cached::value>& __rhn) const
        -: 1772:      {
        -: 1773:	return _S_node_equals(__lhn, __rhn)
        -: 1774:	  && _M_key_equals(_ExtractKey{}(__lhn._M_v()), __rhn);
        -: 1775:      }
        -: 1776:
        -: 1777:      void
    #####: 1778:      _M_swap(_Hashtable_base& __x)
        -: 1779:      {
    #####: 1780:	__hash_code_base::_M_swap(__x);
    #####: 1781:	std::swap(_EqualEBO::_M_get(), __x._EqualEBO::_M_get());
    #####: 1782:      }
        -: 1783:
        -: 1784:      const _Equal&
    1026*: 1785:      _M_eq() const { return _EqualEBO::_M_cget(); }
------------------
_ZNKSt8__detail15_Hashtable_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt4pairIKS6_dENS_10_Select1stESt8equal_toIS6_ESt4hashIS6_ENS_18_Mod_range_hashingENS_20_Default_ranged_hashENS_17_Hashtable_traitsILb1ELb0ELb1EEEE5_M_eqEv:
    #####: 1785:      _M_eq() const { return _EqualEBO::_M_cget(); }
------------------
_ZNKSt8__detail15_Hashtable_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt4pairIKS6_St6vectorIS6_SaIS6_EEENS_10_Select1stESt8equal_toIS6_ESt4hashIS6_ENS_18_Mod_range_hashingENS_20_Default_ranged_hashENS_17_Hashtable_traitsILb1ELb0ELb1EEEE5_M_eqEv:
    #####: 1785:      _M_eq() const { return _EqualEBO::_M_cget(); }
------------------
_ZNKSt8__detail15_Hashtable_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt4pairIKS6_S6_ENS_10_Select1stESt8equal_toIS6_ESt4hashIS6_ENS_18_Mod_range_hashingENS_20_Default_ranged_hashENS_17_Hashtable_traitsILb1ELb0ELb1EEEE5_M_eqEv:
      105: 1785:      _M_eq() const { return _EqualEBO::_M_cget(); }
------------------
_ZNKSt8__detail15_Hashtable_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt4pairIKS6_iENS_10_Select1stESt8equal_toIS6_ESt4hashIS6_ENS_18_Mod_range_hashingENS_20_Default_ranged_hashENS_17_Hashtable_traitsILb1ELb0ELb1EEEE5_M_eqEv:
      353: 1785:      _M_eq() const { return _EqualEBO::_M_cget(); }
------------------
_ZNKSt8__detail15_Hashtable_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt4pairIKS6_St13unordered_mapIS6_iSt4hashIS6_ESt8equal_toIS6_ESaIS7_IS8_iEEEENS_10_Select1stESD_SB_NS_18_Mod_range_hashingENS_20_Default_ranged_hashENS_17_Hashtable_traitsILb1ELb0ELb1EEEE5_M_eqEv:
       49: 1785:      _M_eq() const { return _EqualEBO::_M_cget(); }
------------------
_ZNKSt8__detail15_Hashtable_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES6_NS_9_IdentityESt8equal_toIS6_ESt4hashIS6_ENS_18_Mod_range_hashingENS_20_Default_ranged_hashENS_17_Hashtable_traitsILb1ELb1ELb1EEEE5_M_eqEv:
      519: 1785:      _M_eq() const { return _EqualEBO::_M_cget(); }
------------------
        -: 1786:    };
        -: 1787:
        -: 1788:  /**
        -: 1789:   *  Primary class template  _Equality.
        -: 1790:   *
        -: 1791:   *  This is for implementing equality comparison for unordered
        -: 1792:   *  containers, per N3068, by John Lakos and Pablo Halpern.
        -: 1793:   *  Algorithmically, we follow closely the reference implementations
        -: 1794:   *  therein.
        -: 1795:   */
        -: 1796:  template<typename _Key, typename _Value, typename _Alloc,
        -: 1797:	   typename _ExtractKey, typename _Equal,
        -: 1798:	   typename _Hash, typename _RangeHash, typename _Unused,
        -: 1799:	   typename _RehashPolicy, typename _Traits,
        -: 1800:	   bool _Unique_keys = _Traits::__unique_keys::value>
        -: 1801:    struct _Equality;
        -: 1802:
        -: 1803:  /// unordered_map and unordered_set specializations.
        -: 1804:  template<typename _Key, typename _Value, typename _Alloc,
        -: 1805:	   typename _ExtractKey, typename _Equal,
        -: 1806:	   typename _Hash, typename _RangeHash, typename _Unused,
        -: 1807:	   typename _RehashPolicy, typename _Traits>
        -: 1808:    struct _Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        -: 1809:		     _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits, true>
        -: 1810:    {
        -: 1811:      using __hashtable = _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        -: 1812:				     _Hash, _RangeHash, _Unused,
        -: 1813:				     _RehashPolicy, _Traits>;
        -: 1814:
        -: 1815:      bool
        -: 1816:      _M_equal(const __hashtable&) const;
        -: 1817:    };
        -: 1818:
        -: 1819:  template<typename _Key, typename _Value, typename _Alloc,
        -: 1820:	   typename _ExtractKey, typename _Equal,
        -: 1821:	   typename _Hash, typename _RangeHash, typename _Unused,
        -: 1822:	   typename _RehashPolicy, typename _Traits>
        -: 1823:    bool
        -: 1824:    _Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        -: 1825:	      _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits, true>::
        -: 1826:    _M_equal(const __hashtable& __other) const
        -: 1827:    {
        -: 1828:      using __node_ptr = typename __hashtable::__node_ptr;
        -: 1829:      const __hashtable* __this = static_cast<const __hashtable*>(this);
        -: 1830:      if (__this->size() != __other.size())
        -: 1831:	return false;
        -: 1832:
        -: 1833:      for (auto __x_n = __this->_M_begin(); __x_n; __x_n = __x_n->_M_next())
        -: 1834:	{
        -: 1835:	  std::size_t __ybkt = __other._M_bucket_index(*__x_n);
        -: 1836:	  auto __prev_n = __other._M_buckets[__ybkt];
        -: 1837:	  if (!__prev_n)
        -: 1838:	    return false;
        -: 1839:
        -: 1840:	  for (__node_ptr __n = static_cast<__node_ptr>(__prev_n->_M_nxt);;
        -: 1841:	       __n = __n->_M_next())
        -: 1842:	    {
        -: 1843:	      if (__n->_M_v() == __x_n->_M_v())
        -: 1844:		break;
        -: 1845:
        -: 1846:	      if (!__n->_M_nxt
        -: 1847:		  || __other._M_bucket_index(*__n->_M_next()) != __ybkt)
        -: 1848:		return false;
        -: 1849:	    }
        -: 1850:	}
        -: 1851:
        -: 1852:      return true;
        -: 1853:    }
        -: 1854:
        -: 1855:  /// unordered_multiset and unordered_multimap specializations.
        -: 1856:  template<typename _Key, typename _Value, typename _Alloc,
        -: 1857:	   typename _ExtractKey, typename _Equal,
        -: 1858:	   typename _Hash, typename _RangeHash, typename _Unused,
        -: 1859:	   typename _RehashPolicy, typename _Traits>
        -: 1860:    struct _Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        -: 1861:		     _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits, false>
        -: 1862:    {
        -: 1863:      using __hashtable = _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        -: 1864:				     _Hash, _RangeHash, _Unused,
        -: 1865:				     _RehashPolicy, _Traits>;
        -: 1866:
        -: 1867:      bool
        -: 1868:      _M_equal(const __hashtable&) const;
        -: 1869:    };
        -: 1870:
        -: 1871:  template<typename _Key, typename _Value, typename _Alloc,
        -: 1872:	   typename _ExtractKey, typename _Equal,
        -: 1873:	   typename _Hash, typename _RangeHash, typename _Unused,
        -: 1874:	   typename _RehashPolicy, typename _Traits>
        -: 1875:    bool
        -: 1876:    _Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        -: 1877:	      _Hash, _RangeHash, _Unused, _RehashPolicy, _Traits, false>::
        -: 1878:    _M_equal(const __hashtable& __other) const
        -: 1879:    {
        -: 1880:      using __node_ptr = typename __hashtable::__node_ptr;
        -: 1881:      using const_iterator = typename __hashtable::const_iterator;
        -: 1882:      const __hashtable* __this = static_cast<const __hashtable*>(this);
        -: 1883:      if (__this->size() != __other.size())
        -: 1884:	return false;
        -: 1885:
        -: 1886:      for (auto __x_n = __this->_M_begin(); __x_n;)
        -: 1887:	{
        -: 1888:	  std::size_t __x_count = 1;
        -: 1889:	  auto __x_n_end = __x_n->_M_next();
        -: 1890:	  for (; __x_n_end
        -: 1891:		 && __this->key_eq()(_ExtractKey{}(__x_n->_M_v()),
        -: 1892:				     _ExtractKey{}(__x_n_end->_M_v()));
        -: 1893:	       __x_n_end = __x_n_end->_M_next())
        -: 1894:	    ++__x_count;
        -: 1895:
        -: 1896:	  std::size_t __ybkt = __other._M_bucket_index(*__x_n);
        -: 1897:	  auto __y_prev_n = __other._M_buckets[__ybkt];
        -: 1898:	  if (!__y_prev_n)
        -: 1899:	    return false;
        -: 1900:
        -: 1901:	  __node_ptr __y_n = static_cast<__node_ptr>(__y_prev_n->_M_nxt);
        -: 1902:	  for (;;)
        -: 1903:	    {
        -: 1904:	      if (__this->key_eq()(_ExtractKey{}(__y_n->_M_v()),
        -: 1905:				   _ExtractKey{}(__x_n->_M_v())))
        -: 1906:		break;
        -: 1907:
        -: 1908:	      auto __y_ref_n = __y_n;
        -: 1909:	      for (__y_n = __y_n->_M_next(); __y_n; __y_n = __y_n->_M_next())
        -: 1910:		if (!__other._M_node_equals(*__y_ref_n, *__y_n))
        -: 1911:		  break;
        -: 1912:
        -: 1913:	      if (!__y_n || __other._M_bucket_index(*__y_n) != __ybkt)
        -: 1914:		return false;
        -: 1915:	    }
        -: 1916:
        -: 1917:	  auto __y_n_end = __y_n;
        -: 1918:	  for (; __y_n_end; __y_n_end = __y_n_end->_M_next())
        -: 1919:	    if (--__x_count == 0)
        -: 1920:	      break;
        -: 1921:
        -: 1922:	  if (__x_count != 0)
        -: 1923:	    return false;
        -: 1924:
        -: 1925:	  const_iterator __itx(__x_n), __itx_end(__x_n_end);
        -: 1926:	  const_iterator __ity(__y_n);
        -: 1927:	  if (!std::is_permutation(__itx, __itx_end, __ity))
        -: 1928:	    return false;
        -: 1929:
        -: 1930:	  __x_n = __x_n_end;
        -: 1931:	}
        -: 1932:      return true;
        -: 1933:    }
        -: 1934:
        -: 1935:  /**
        -: 1936:   * This type deals with all allocation and keeps an allocator instance
        -: 1937:   * through inheritance to benefit from EBO when possible.
        -: 1938:   */
        -: 1939:  template<typename _NodeAlloc>
        -: 1940:    struct _Hashtable_alloc : private _Hashtable_ebo_helper<0, _NodeAlloc>
        -: 1941:    {
        -: 1942:    private:
        -: 1943:      using __ebo_node_alloc = _Hashtable_ebo_helper<0, _NodeAlloc>;
        -: 1944:
        -: 1945:      template<typename>
        -: 1946:	struct __get_value_type;
        -: 1947:      template<typename _Val, bool _Cache_hash_code>
        -: 1948:	struct __get_value_type<_Hash_node<_Val, _Cache_hash_code>>
        -: 1949:	{ using type = _Val; };
        -: 1950:
        -: 1951:    public:
        -: 1952:      using __node_type = typename _NodeAlloc::value_type;
        -: 1953:      using __node_alloc_type = _NodeAlloc;
        -: 1954:      // Use __gnu_cxx to benefit from _S_always_equal and al.
        -: 1955:      using __node_alloc_traits = __gnu_cxx::__alloc_traits<__node_alloc_type>;
        -: 1956:
        -: 1957:      using __value_alloc_traits = typename __node_alloc_traits::template
        -: 1958:	rebind_traits<typename __get_value_type<__node_type>::type>;
        -: 1959:
        -: 1960:      using __node_ptr = __node_type*;
        -: 1961:      using __node_base = _Hash_node_base;
        -: 1962:      using __node_base_ptr = __node_base*;
        -: 1963:      using __buckets_alloc_type =
        -: 1964:	__alloc_rebind<__node_alloc_type, __node_base_ptr>;
        -: 1965:      using __buckets_alloc_traits = std::allocator_traits<__buckets_alloc_type>;
        -: 1966:      using __buckets_ptr = __node_base_ptr*;
        -: 1967:
     183*: 1968:      _Hashtable_alloc() = default;
------------------
_ZNSt8__detail16_Hashtable_allocISaINS_10_Hash_nodeISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEdELb1EEEEEC2Ev:
    #####: 1968:      _Hashtable_alloc() = default;
------------------
_ZNSt8__detail16_Hashtable_allocISaINS_10_Hash_nodeISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_ELb1EEEEEC2Ev:
       37: 1968:      _Hashtable_alloc() = default;
------------------
_ZNSt8__detail16_Hashtable_allocISaINS_10_Hash_nodeISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEiELb1EEEEEC2Ev:
      125: 1968:      _Hashtable_alloc() = default;
------------------
_ZNSt8__detail16_Hashtable_allocISaINS_10_Hash_nodeINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEELb1EEEEEC2Ev:
        7: 1968:      _Hashtable_alloc() = default;
------------------
_ZNSt8__detail16_Hashtable_allocISaINS_10_Hash_nodeISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt6vectorIS8_SaIS8_EEELb1EEEEEC2Ev:
        7: 1968:      _Hashtable_alloc() = default;
------------------
_ZNSt8__detail16_Hashtable_allocISaINS_10_Hash_nodeISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt13unordered_mapIS8_iSt4hashIS8_ESt8equal_toIS8_ESaIS2_IS9_iEEEELb1EEEEEC2Ev:
        7: 1968:      _Hashtable_alloc() = default;
------------------
        -: 1969:      _Hashtable_alloc(const _Hashtable_alloc&) = default;
        -: 1970:      _Hashtable_alloc(_Hashtable_alloc&&) = default;
        -: 1971:
        -: 1972:      template<typename _Alloc>
    #####: 1973:	_Hashtable_alloc(_Alloc&& __a)
    #####: 1974:	: __ebo_node_alloc(std::forward<_Alloc>(__a))
    #####: 1975:	{ }
        -: 1976:
        -: 1977:      __node_alloc_type&
    1826*: 1978:      _M_node_allocator()
    1826*: 1979:      { return __ebo_node_alloc::_M_get(); }
------------------
_ZNSt8__detail16_Hashtable_allocISaINS_10_Hash_nodeISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_ELb1EEEEE17_M_node_allocatorEv:
      189: 1978:      _M_node_allocator()
      189: 1979:      { return __ebo_node_alloc::_M_get(); }
------------------
_ZNSt8__detail16_Hashtable_allocISaINS_10_Hash_nodeISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEiELb1EEEEE17_M_node_allocatorEv:
      838: 1978:      _M_node_allocator()
      838: 1979:      { return __ebo_node_alloc::_M_get(); }
------------------
_ZNSt8__detail16_Hashtable_allocISaINS_10_Hash_nodeINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEELb1EEEEE17_M_node_allocatorEv:
      328: 1978:      _M_node_allocator()
      328: 1979:      { return __ebo_node_alloc::_M_get(); }
------------------
_ZNSt8__detail16_Hashtable_allocISaINS_10_Hash_nodeISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt6vectorIS8_SaIS8_EEELb1EEEEE17_M_node_allocatorEv:
      240: 1978:      _M_node_allocator()
      240: 1979:      { return __ebo_node_alloc::_M_get(); }
------------------
_ZNSt8__detail16_Hashtable_allocISaINS_10_Hash_nodeISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt13unordered_mapIS8_iSt4hashIS8_ESt8equal_toIS8_ESaIS2_IS9_iEEEELb1EEEEE17_M_node_allocatorEv:
      231: 1978:      _M_node_allocator()
      231: 1979:      { return __ebo_node_alloc::_M_get(); }
------------------
_ZNSt8__detail16_Hashtable_allocISaINS_10_Hash_nodeISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEdELb1EEEEE17_M_node_allocatorEv:
    #####: 1978:      _M_node_allocator()
    #####: 1979:      { return __ebo_node_alloc::_M_get(); }
------------------
        -: 1980:
        -: 1981:      const __node_alloc_type&
        -: 1982:      _M_node_allocator() const
        -: 1983:      { return __ebo_node_alloc::_M_cget(); }
        -: 1984:
        -: 1985:      // Allocate a node and construct an element within it.
        -: 1986:      template<typename... _Args>
        -: 1987:	__node_ptr
        -: 1988:	_M_allocate_node(_Args&&... __args);
        -: 1989:
        -: 1990:      // Destroy the element within a node and deallocate the node.
        -: 1991:      void
        -: 1992:      _M_deallocate_node(__node_ptr __n);
        -: 1993:
        -: 1994:      // Deallocate a node.
        -: 1995:      void
        -: 1996:      _M_deallocate_node_ptr(__node_ptr __n);
        -: 1997:
        -: 1998:      // Deallocate the linked list of nodes pointed to by __n.
        -: 1999:      // The elements within the nodes are destroyed.
        -: 2000:      void
        -: 2001:      _M_deallocate_nodes(__node_ptr __n);
        -: 2002:
        -: 2003:      __buckets_ptr
        -: 2004:      _M_allocate_buckets(std::size_t __bkt_count);
        -: 2005:
        -: 2006:      void
        -: 2007:      _M_deallocate_buckets(__buckets_ptr, std::size_t __bkt_count);
        -: 2008:    };
        -: 2009:
        -: 2010:  // Definitions of class template _Hashtable_alloc's out-of-line member
        -: 2011:  // functions.
        -: 2012:  template<typename _NodeAlloc>
        -: 2013:    template<typename... _Args>
        -: 2014:      auto
     577*: 2015:      _Hashtable_alloc<_NodeAlloc>::_M_allocate_node(_Args&&... __args)
        -: 2016:      -> __node_ptr
        -: 2017:      {
     577*: 2018:	auto& __alloc = _M_node_allocator();
     577*: 2019:	auto __nptr = __node_alloc_traits::allocate(__alloc, 1);
     577*: 2020:	__node_ptr __n = std::__to_address(__nptr);
        -: 2021:	__try
        -: 2022:	  {
     577*: 2023:	    ::new ((void*)__n) __node_type;
    1154*: 2024:	    __node_alloc_traits::construct(__alloc, __n->_M_valptr(),
        -: 2025:					   std::forward<_Args>(__args)...);
     577*: 2026:	    return __n;
        -: 2027:	  }
    =====: 2028:	__catch(...)
        -: 2029:	  {
    =====: 2030:	    __n->~__node_type();
        -: 2031:	    __node_alloc_traits::deallocate(__alloc, __nptr, 1);
    =====: 2032:	    __throw_exception_again;
        -: 2033:	  }
        -: 2034:      }
------------------
_ZNSt8__detail16_Hashtable_allocISaINS_10_Hash_nodeINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEELb1EEEEE16_M_allocate_nodeIJRKS7_EEEPS8_DpOT_:
      125: 2015:      _Hashtable_alloc<_NodeAlloc>::_M_allocate_node(_Args&&... __args)
        -: 2016:      -> __node_ptr
        -: 2017:      {
      125: 2018:	auto& __alloc = _M_node_allocator();
      125: 2019:	auto __nptr = __node_alloc_traits::allocate(__alloc, 1);
      125: 2020:	__node_ptr __n = std::__to_address(__nptr);
        -: 2021:	__try
        -: 2022:	  {
      125: 2023:	    ::new ((void*)__n) __node_type;
      250: 2024:	    __node_alloc_traits::construct(__alloc, __n->_M_valptr(),
        -: 2025:					   std::forward<_Args>(__args)...);
      125: 2026:	    return __n;
        -: 2027:	  }
    =====: 2028:	__catch(...)
        -: 2029:	  {
    =====: 2030:	    __n->~__node_type();
        -: 2031:	    __node_alloc_traits::deallocate(__alloc, __nptr, 1);
    =====: 2032:	    __throw_exception_again;
        -: 2033:	  }
        -: 2034:      }
------------------
_ZNSt8__detail16_Hashtable_allocISaINS_10_Hash_nodeISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEdELb1EEEEE16_M_allocate_nodeIJRKSt21piecewise_construct_tSt5tupleIJRS9_EESI_IJEEEEEPSB_DpOT_:
    #####: 2015:      _Hashtable_alloc<_NodeAlloc>::_M_allocate_node(_Args&&... __args)
        -: 2016:      -> __node_ptr
        -: 2017:      {
    #####: 2018:	auto& __alloc = _M_node_allocator();
    #####: 2019:	auto __nptr = __node_alloc_traits::allocate(__alloc, 1);
    #####: 2020:	__node_ptr __n = std::__to_address(__nptr);
        -: 2021:	__try
        -: 2022:	  {
    #####: 2023:	    ::new ((void*)__n) __node_type;
    #####: 2024:	    __node_alloc_traits::construct(__alloc, __n->_M_valptr(),
        -: 2025:					   std::forward<_Args>(__args)...);
    #####: 2026:	    return __n;
        -: 2027:	  }
    =====: 2028:	__catch(...)
        -: 2029:	  {
    =====: 2030:	    __n->~__node_type();
        -: 2031:	    __node_alloc_traits::deallocate(__alloc, __nptr, 1);
    =====: 2032:	    __throw_exception_again;
        -: 2033:	  }
        -: 2034:      }
------------------
_ZNSt8__detail16_Hashtable_allocISaINS_10_Hash_nodeISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_ELb1EEEEE16_M_allocate_nodeIJRKSt21piecewise_construct_tSt5tupleIJRS9_EESI_IJEEEEEPSB_DpOT_:
       49: 2015:      _Hashtable_alloc<_NodeAlloc>::_M_allocate_node(_Args&&... __args)
        -: 2016:      -> __node_ptr
        -: 2017:      {
       49: 2018:	auto& __alloc = _M_node_allocator();
       49: 2019:	auto __nptr = __node_alloc_traits::allocate(__alloc, 1);
       49: 2020:	__node_ptr __n = std::__to_address(__nptr);
        -: 2021:	__try
        -: 2022:	  {
       49: 2023:	    ::new ((void*)__n) __node_type;
       98: 2024:	    __node_alloc_traits::construct(__alloc, __n->_M_valptr(),
        -: 2025:					   std::forward<_Args>(__args)...);
       49: 2026:	    return __n;
        -: 2027:	  }
    =====: 2028:	__catch(...)
        -: 2029:	  {
    =====: 2030:	    __n->~__node_type();
        -: 2031:	    __node_alloc_traits::deallocate(__alloc, __nptr, 1);
    =====: 2032:	    __throw_exception_again;
        -: 2033:	  }
        -: 2034:      }
------------------
_ZNSt8__detail16_Hashtable_allocISaINS_10_Hash_nodeISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt6vectorIS8_SaIS8_EEELb1EEEEE16_M_allocate_nodeIJRKSt21piecewise_construct_tSt5tupleIJRS9_EESL_IJEEEEEPSE_DpOT_:
       95: 2015:      _Hashtable_alloc<_NodeAlloc>::_M_allocate_node(_Args&&... __args)
        -: 2016:      -> __node_ptr
        -: 2017:      {
       95: 2018:	auto& __alloc = _M_node_allocator();
       95: 2019:	auto __nptr = __node_alloc_traits::allocate(__alloc, 1);
       95: 2020:	__node_ptr __n = std::__to_address(__nptr);
        -: 2021:	__try
        -: 2022:	  {
       95: 2023:	    ::new ((void*)__n) __node_type;
      190: 2024:	    __node_alloc_traits::construct(__alloc, __n->_M_valptr(),
        -: 2025:					   std::forward<_Args>(__args)...);
       95: 2026:	    return __n;
        -: 2027:	  }
    =====: 2028:	__catch(...)
        -: 2029:	  {
    =====: 2030:	    __n->~__node_type();
        -: 2031:	    __node_alloc_traits::deallocate(__alloc, __nptr, 1);
    =====: 2032:	    __throw_exception_again;
        -: 2033:	  }
        -: 2034:      }
------------------
_ZNSt8__detail16_Hashtable_allocISaINS_10_Hash_nodeISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEiELb1EEEEE16_M_allocate_nodeIJRKSt21piecewise_construct_tSt5tupleIJRS9_EESI_IJEEEEEPSB_DpOT_:
      220: 2015:      _Hashtable_alloc<_NodeAlloc>::_M_allocate_node(_Args&&... __args)
        -: 2016:      -> __node_ptr
        -: 2017:      {
      220: 2018:	auto& __alloc = _M_node_allocator();
      220: 2019:	auto __nptr = __node_alloc_traits::allocate(__alloc, 1);
      220: 2020:	__node_ptr __n = std::__to_address(__nptr);
        -: 2021:	__try
        -: 2022:	  {
      220: 2023:	    ::new ((void*)__n) __node_type;
      440: 2024:	    __node_alloc_traits::construct(__alloc, __n->_M_valptr(),
        -: 2025:					   std::forward<_Args>(__args)...);
      220: 2026:	    return __n;
        -: 2027:	  }
    =====: 2028:	__catch(...)
        -: 2029:	  {
    =====: 2030:	    __n->~__node_type();
        -: 2031:	    __node_alloc_traits::deallocate(__alloc, __nptr, 1);
    =====: 2032:	    __throw_exception_again;
        -: 2033:	  }
        -: 2034:      }
------------------
_ZNSt8__detail16_Hashtable_allocISaINS_10_Hash_nodeISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt13unordered_mapIS8_iSt4hashIS8_ESt8equal_toIS8_ESaIS2_IS9_iEEEELb1EEEEE16_M_allocate_nodeIJRKSt21piecewise_construct_tSt5tupleIJRS9_EESQ_IJEEEEEPSJ_DpOT_:
       88: 2015:      _Hashtable_alloc<_NodeAlloc>::_M_allocate_node(_Args&&... __args)
        -: 2016:      -> __node_ptr
        -: 2017:      {
       88: 2018:	auto& __alloc = _M_node_allocator();
       88: 2019:	auto __nptr = __node_alloc_traits::allocate(__alloc, 1);
       88: 2020:	__node_ptr __n = std::__to_address(__nptr);
        -: 2021:	__try
        -: 2022:	  {
       88: 2023:	    ::new ((void*)__n) __node_type;
      176: 2024:	    __node_alloc_traits::construct(__alloc, __n->_M_valptr(),
        -: 2025:					   std::forward<_Args>(__args)...);
       88: 2026:	    return __n;
        -: 2027:	  }
    =====: 2028:	__catch(...)
        -: 2029:	  {
    =====: 2030:	    __n->~__node_type();
        -: 2031:	    __node_alloc_traits::deallocate(__alloc, __nptr, 1);
    =====: 2032:	    __throw_exception_again;
        -: 2033:	  }
        -: 2034:      }
------------------
        -: 2035:
        -: 2036:  template<typename _NodeAlloc>
        -: 2037:    void
     478*: 2038:    _Hashtable_alloc<_NodeAlloc>::_M_deallocate_node(__node_ptr __n)
        -: 2039:    {
     956*: 2040:      __node_alloc_traits::destroy(_M_node_allocator(), __n->_M_valptr());
     478*: 2041:      _M_deallocate_node_ptr(__n);
     478*: 2042:    }
------------------
_ZNSt8__detail16_Hashtable_allocISaINS_10_Hash_nodeISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEdELb1EEEEE18_M_deallocate_nodeEPSB_:
    #####: 2038:    _Hashtable_alloc<_NodeAlloc>::_M_deallocate_node(__node_ptr __n)
        -: 2039:    {
    #####: 2040:      __node_alloc_traits::destroy(_M_node_allocator(), __n->_M_valptr());
    #####: 2041:      _M_deallocate_node_ptr(__n);
    #####: 2042:    }
------------------
_ZNSt8__detail16_Hashtable_allocISaINS_10_Hash_nodeISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_ELb1EEEEE18_M_deallocate_nodeEPSB_:
       49: 2038:    _Hashtable_alloc<_NodeAlloc>::_M_deallocate_node(__node_ptr __n)
        -: 2039:    {
       98: 2040:      __node_alloc_traits::destroy(_M_node_allocator(), __n->_M_valptr());
       49: 2041:      _M_deallocate_node_ptr(__n);
       49: 2042:    }
------------------
_ZNSt8__detail16_Hashtable_allocISaINS_10_Hash_nodeISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEiELb1EEEEE18_M_deallocate_nodeEPSB_:
      194: 2038:    _Hashtable_alloc<_NodeAlloc>::_M_deallocate_node(__node_ptr __n)
        -: 2039:    {
      388: 2040:      __node_alloc_traits::destroy(_M_node_allocator(), __n->_M_valptr());
      194: 2041:      _M_deallocate_node_ptr(__n);
      194: 2042:    }
------------------
_ZNSt8__detail16_Hashtable_allocISaINS_10_Hash_nodeINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEELb1EEEEE18_M_deallocate_nodeEPS8_:
       98: 2038:    _Hashtable_alloc<_NodeAlloc>::_M_deallocate_node(__node_ptr __n)
        -: 2039:    {
      196: 2040:      __node_alloc_traits::destroy(_M_node_allocator(), __n->_M_valptr());
       98: 2041:      _M_deallocate_node_ptr(__n);
       98: 2042:    }
------------------
_ZNSt8__detail16_Hashtable_allocISaINS_10_Hash_nodeISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt6vectorIS8_SaIS8_EEELb1EEEEE18_M_deallocate_nodeEPSE_:
       69: 2038:    _Hashtable_alloc<_NodeAlloc>::_M_deallocate_node(__node_ptr __n)
        -: 2039:    {
      138: 2040:      __node_alloc_traits::destroy(_M_node_allocator(), __n->_M_valptr());
       69: 2041:      _M_deallocate_node_ptr(__n);
       69: 2042:    }
------------------
_ZNSt8__detail16_Hashtable_allocISaINS_10_Hash_nodeISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt13unordered_mapIS8_iSt4hashIS8_ESt8equal_toIS8_ESaIS2_IS9_iEEEELb1EEEEE18_M_deallocate_nodeEPSJ_:
       68: 2038:    _Hashtable_alloc<_NodeAlloc>::_M_deallocate_node(__node_ptr __n)
        -: 2039:    {
      136: 2040:      __node_alloc_traits::destroy(_M_node_allocator(), __n->_M_valptr());
       68: 2041:      _M_deallocate_node_ptr(__n);
       68: 2042:    }
------------------
        -: 2043:
        -: 2044:  template<typename _NodeAlloc>
        -: 2045:    void
     478*: 2046:    _Hashtable_alloc<_NodeAlloc>::_M_deallocate_node_ptr(__node_ptr __n)
        -: 2047:    {
        -: 2048:      typedef typename __node_alloc_traits::pointer _Ptr;
     478*: 2049:      auto __ptr = std::pointer_traits<_Ptr>::pointer_to(*__n);
     478*: 2050:      __n->~__node_type();
     478*: 2051:      __node_alloc_traits::deallocate(_M_node_allocator(), __ptr, 1);
     478*: 2052:    }
------------------
_ZNSt8__detail16_Hashtable_allocISaINS_10_Hash_nodeISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEdELb1EEEEE22_M_deallocate_node_ptrEPSB_:
    #####: 2046:    _Hashtable_alloc<_NodeAlloc>::_M_deallocate_node_ptr(__node_ptr __n)
        -: 2047:    {
        -: 2048:      typedef typename __node_alloc_traits::pointer _Ptr;
    #####: 2049:      auto __ptr = std::pointer_traits<_Ptr>::pointer_to(*__n);
    #####: 2050:      __n->~__node_type();
    #####: 2051:      __node_alloc_traits::deallocate(_M_node_allocator(), __ptr, 1);
    #####: 2052:    }
------------------
_ZNSt8__detail16_Hashtable_allocISaINS_10_Hash_nodeISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_ELb1EEEEE22_M_deallocate_node_ptrEPSB_:
       49: 2046:    _Hashtable_alloc<_NodeAlloc>::_M_deallocate_node_ptr(__node_ptr __n)
        -: 2047:    {
        -: 2048:      typedef typename __node_alloc_traits::pointer _Ptr;
       49: 2049:      auto __ptr = std::pointer_traits<_Ptr>::pointer_to(*__n);
       49: 2050:      __n->~__node_type();
       49: 2051:      __node_alloc_traits::deallocate(_M_node_allocator(), __ptr, 1);
       49: 2052:    }
------------------
_ZNSt8__detail16_Hashtable_allocISaINS_10_Hash_nodeISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEiELb1EEEEE22_M_deallocate_node_ptrEPSB_:
      194: 2046:    _Hashtable_alloc<_NodeAlloc>::_M_deallocate_node_ptr(__node_ptr __n)
        -: 2047:    {
        -: 2048:      typedef typename __node_alloc_traits::pointer _Ptr;
      194: 2049:      auto __ptr = std::pointer_traits<_Ptr>::pointer_to(*__n);
      194: 2050:      __n->~__node_type();
      194: 2051:      __node_alloc_traits::deallocate(_M_node_allocator(), __ptr, 1);
      194: 2052:    }
------------------
_ZNSt8__detail16_Hashtable_allocISaINS_10_Hash_nodeINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEELb1EEEEE22_M_deallocate_node_ptrEPS8_:
       98: 2046:    _Hashtable_alloc<_NodeAlloc>::_M_deallocate_node_ptr(__node_ptr __n)
        -: 2047:    {
        -: 2048:      typedef typename __node_alloc_traits::pointer _Ptr;
       98: 2049:      auto __ptr = std::pointer_traits<_Ptr>::pointer_to(*__n);
       98: 2050:      __n->~__node_type();
       98: 2051:      __node_alloc_traits::deallocate(_M_node_allocator(), __ptr, 1);
       98: 2052:    }
------------------
_ZNSt8__detail16_Hashtable_allocISaINS_10_Hash_nodeISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt6vectorIS8_SaIS8_EEELb1EEEEE22_M_deallocate_node_ptrEPSE_:
       69: 2046:    _Hashtable_alloc<_NodeAlloc>::_M_deallocate_node_ptr(__node_ptr __n)
        -: 2047:    {
        -: 2048:      typedef typename __node_alloc_traits::pointer _Ptr;
       69: 2049:      auto __ptr = std::pointer_traits<_Ptr>::pointer_to(*__n);
       69: 2050:      __n->~__node_type();
       69: 2051:      __node_alloc_traits::deallocate(_M_node_allocator(), __ptr, 1);
       69: 2052:    }
------------------
_ZNSt8__detail16_Hashtable_allocISaINS_10_Hash_nodeISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt13unordered_mapIS8_iSt4hashIS8_ESt8equal_toIS8_ESaIS2_IS9_iEEEELb1EEEEE22_M_deallocate_node_ptrEPSJ_:
       68: 2046:    _Hashtable_alloc<_NodeAlloc>::_M_deallocate_node_ptr(__node_ptr __n)
        -: 2047:    {
        -: 2048:      typedef typename __node_alloc_traits::pointer _Ptr;
       68: 2049:      auto __ptr = std::pointer_traits<_Ptr>::pointer_to(*__n);
       68: 2050:      __n->~__node_type();
       68: 2051:      __node_alloc_traits::deallocate(_M_node_allocator(), __ptr, 1);
       68: 2052:    }
------------------
        -: 2053:
        -: 2054:  template<typename _NodeAlloc>
        -: 2055:    void
     253*: 2056:    _Hashtable_alloc<_NodeAlloc>::_M_deallocate_nodes(__node_ptr __n)
        -: 2057:    {
     731*: 2058:      while (__n)
        -: 2059:	{
     478*: 2060:	  __node_ptr __tmp = __n;
     478*: 2061:	  __n = __n->_M_next();
     478*: 2062:	  _M_deallocate_node(__tmp);
        -: 2063:	}
     253*: 2064:    }
------------------
_ZNSt8__detail16_Hashtable_allocISaINS_10_Hash_nodeISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEdELb1EEEEE19_M_deallocate_nodesEPSB_:
    #####: 2056:    _Hashtable_alloc<_NodeAlloc>::_M_deallocate_nodes(__node_ptr __n)
        -: 2057:    {
    #####: 2058:      while (__n)
        -: 2059:	{
    #####: 2060:	  __node_ptr __tmp = __n;
    #####: 2061:	  __n = __n->_M_next();
    #####: 2062:	  _M_deallocate_node(__tmp);
        -: 2063:	}
    #####: 2064:    }
------------------
_ZNSt8__detail16_Hashtable_allocISaINS_10_Hash_nodeISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_ELb1EEEEE19_M_deallocate_nodesEPSB_:
       37: 2056:    _Hashtable_alloc<_NodeAlloc>::_M_deallocate_nodes(__node_ptr __n)
        -: 2057:    {
       86: 2058:      while (__n)
        -: 2059:	{
       49: 2060:	  __node_ptr __tmp = __n;
       49: 2061:	  __n = __n->_M_next();
       49: 2062:	  _M_deallocate_node(__tmp);
        -: 2063:	}
       37: 2064:    }
------------------
_ZNSt8__detail16_Hashtable_allocISaINS_10_Hash_nodeISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEiELb1EEEEE19_M_deallocate_nodesEPSB_:
      105: 2056:    _Hashtable_alloc<_NodeAlloc>::_M_deallocate_nodes(__node_ptr __n)
        -: 2057:    {
      299: 2058:      while (__n)
        -: 2059:	{
      194: 2060:	  __node_ptr __tmp = __n;
      194: 2061:	  __n = __n->_M_next();
      194: 2062:	  _M_deallocate_node(__tmp);
        -: 2063:	}
      105: 2064:    }
------------------
_ZNSt8__detail16_Hashtable_allocISaINS_10_Hash_nodeINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEELb1EEEEE19_M_deallocate_nodesEPS8_:
       37: 2056:    _Hashtable_alloc<_NodeAlloc>::_M_deallocate_nodes(__node_ptr __n)
        -: 2057:    {
      135: 2058:      while (__n)
        -: 2059:	{
       98: 2060:	  __node_ptr __tmp = __n;
       98: 2061:	  __n = __n->_M_next();
       98: 2062:	  _M_deallocate_node(__tmp);
        -: 2063:	}
       37: 2064:    }
------------------
_ZNSt8__detail16_Hashtable_allocISaINS_10_Hash_nodeISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt6vectorIS8_SaIS8_EEELb1EEEEE19_M_deallocate_nodesEPSE_:
       37: 2056:    _Hashtable_alloc<_NodeAlloc>::_M_deallocate_nodes(__node_ptr __n)
        -: 2057:    {
      106: 2058:      while (__n)
        -: 2059:	{
       69: 2060:	  __node_ptr __tmp = __n;
       69: 2061:	  __n = __n->_M_next();
       69: 2062:	  _M_deallocate_node(__tmp);
        -: 2063:	}
       37: 2064:    }
------------------
_ZNSt8__detail16_Hashtable_allocISaINS_10_Hash_nodeISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt13unordered_mapIS8_iSt4hashIS8_ESt8equal_toIS8_ESaIS2_IS9_iEEEELb1EEEEE19_M_deallocate_nodesEPSJ_:
       37: 2056:    _Hashtable_alloc<_NodeAlloc>::_M_deallocate_nodes(__node_ptr __n)
        -: 2057:    {
      105: 2058:      while (__n)
        -: 2059:	{
       68: 2060:	  __node_ptr __tmp = __n;
       68: 2061:	  __n = __n->_M_next();
       68: 2062:	  _M_deallocate_node(__tmp);
        -: 2063:	}
       37: 2064:    }
------------------
        -: 2065:
        -: 2066:  template<typename _NodeAlloc>
        -: 2067:    auto
     167*: 2068:    _Hashtable_alloc<_NodeAlloc>::_M_allocate_buckets(std::size_t __bkt_count)
        -: 2069:    -> __buckets_ptr
        -: 2070:    {
     167*: 2071:      __buckets_alloc_type __alloc(_M_node_allocator());
        -: 2072:
     167*: 2073:      auto __ptr = __buckets_alloc_traits::allocate(__alloc, __bkt_count);
     167*: 2074:      __buckets_ptr __p = std::__to_address(__ptr);
     167*: 2075:      __builtin_memset(__p, 0, __bkt_count * sizeof(__node_base_ptr));
     334*: 2076:      return __p;
        -: 2077:    }
------------------
_ZNSt8__detail16_Hashtable_allocISaINS_10_Hash_nodeINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEELb1EEEEE19_M_allocate_bucketsEy:
        7: 2068:    _Hashtable_alloc<_NodeAlloc>::_M_allocate_buckets(std::size_t __bkt_count)
        -: 2069:    -> __buckets_ptr
        -: 2070:    {
        7: 2071:      __buckets_alloc_type __alloc(_M_node_allocator());
        -: 2072:
        7: 2073:      auto __ptr = __buckets_alloc_traits::allocate(__alloc, __bkt_count);
        7: 2074:      __buckets_ptr __p = std::__to_address(__ptr);
        7: 2075:      __builtin_memset(__p, 0, __bkt_count * sizeof(__node_base_ptr));
       14: 2076:      return __p;
        -: 2077:    }
------------------
_ZNSt8__detail16_Hashtable_allocISaINS_10_Hash_nodeISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEdELb1EEEEE19_M_allocate_bucketsEy:
    #####: 2068:    _Hashtable_alloc<_NodeAlloc>::_M_allocate_buckets(std::size_t __bkt_count)
        -: 2069:    -> __buckets_ptr
        -: 2070:    {
    #####: 2071:      __buckets_alloc_type __alloc(_M_node_allocator());
        -: 2072:
    #####: 2073:      auto __ptr = __buckets_alloc_traits::allocate(__alloc, __bkt_count);
    #####: 2074:      __buckets_ptr __p = std::__to_address(__ptr);
    #####: 2075:      __builtin_memset(__p, 0, __bkt_count * sizeof(__node_base_ptr));
    #####: 2076:      return __p;
        -: 2077:    }
------------------
_ZNSt8__detail16_Hashtable_allocISaINS_10_Hash_nodeISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_ELb1EEEEE19_M_allocate_bucketsEy:
       21: 2068:    _Hashtable_alloc<_NodeAlloc>::_M_allocate_buckets(std::size_t __bkt_count)
        -: 2069:    -> __buckets_ptr
        -: 2070:    {
       21: 2071:      __buckets_alloc_type __alloc(_M_node_allocator());
        -: 2072:
       21: 2073:      auto __ptr = __buckets_alloc_traits::allocate(__alloc, __bkt_count);
       21: 2074:      __buckets_ptr __p = std::__to_address(__ptr);
       21: 2075:      __builtin_memset(__p, 0, __bkt_count * sizeof(__node_base_ptr));
       42: 2076:      return __p;
        -: 2077:    }
------------------
_ZNSt8__detail16_Hashtable_allocISaINS_10_Hash_nodeISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt6vectorIS8_SaIS8_EEELb1EEEEE19_M_allocate_bucketsEy:
        7: 2068:    _Hashtable_alloc<_NodeAlloc>::_M_allocate_buckets(std::size_t __bkt_count)
        -: 2069:    -> __buckets_ptr
        -: 2070:    {
        7: 2071:      __buckets_alloc_type __alloc(_M_node_allocator());
        -: 2072:
        7: 2073:      auto __ptr = __buckets_alloc_traits::allocate(__alloc, __bkt_count);
        7: 2074:      __buckets_ptr __p = std::__to_address(__ptr);
        7: 2075:      __builtin_memset(__p, 0, __bkt_count * sizeof(__node_base_ptr));
       14: 2076:      return __p;
        -: 2077:    }
------------------
_ZNSt8__detail16_Hashtable_allocISaINS_10_Hash_nodeISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEiELb1EEEEE19_M_allocate_bucketsEy:
      125: 2068:    _Hashtable_alloc<_NodeAlloc>::_M_allocate_buckets(std::size_t __bkt_count)
        -: 2069:    -> __buckets_ptr
        -: 2070:    {
      125: 2071:      __buckets_alloc_type __alloc(_M_node_allocator());
        -: 2072:
      125: 2073:      auto __ptr = __buckets_alloc_traits::allocate(__alloc, __bkt_count);
      125: 2074:      __buckets_ptr __p = std::__to_address(__ptr);
      125: 2075:      __builtin_memset(__p, 0, __bkt_count * sizeof(__node_base_ptr));
      250: 2076:      return __p;
        -: 2077:    }
------------------
_ZNSt8__detail16_Hashtable_allocISaINS_10_Hash_nodeISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt13unordered_mapIS8_iSt4hashIS8_ESt8equal_toIS8_ESaIS2_IS9_iEEEELb1EEEEE19_M_allocate_bucketsEy:
        7: 2068:    _Hashtable_alloc<_NodeAlloc>::_M_allocate_buckets(std::size_t __bkt_count)
        -: 2069:    -> __buckets_ptr
        -: 2070:    {
        7: 2071:      __buckets_alloc_type __alloc(_M_node_allocator());
        -: 2072:
        7: 2073:      auto __ptr = __buckets_alloc_traits::allocate(__alloc, __bkt_count);
        7: 2074:      __buckets_ptr __p = std::__to_address(__ptr);
        7: 2075:      __builtin_memset(__p, 0, __bkt_count * sizeof(__node_base_ptr));
       14: 2076:      return __p;
        -: 2077:    }
------------------
        -: 2078:
        -: 2079:  template<typename _NodeAlloc>
        -: 2080:    void
     126*: 2081:    _Hashtable_alloc<_NodeAlloc>::
        -: 2082:    _M_deallocate_buckets(__buckets_ptr __bkts,
        -: 2083:			  std::size_t __bkt_count)
        -: 2084:    {
        -: 2085:      typedef typename __buckets_alloc_traits::pointer _Ptr;
     126*: 2086:      auto __ptr = std::pointer_traits<_Ptr>::pointer_to(*__bkts);
     126*: 2087:      __buckets_alloc_type __alloc(_M_node_allocator());
        -: 2088:      __buckets_alloc_traits::deallocate(__alloc, __ptr, __bkt_count);
     126*: 2089:    }
------------------
_ZNSt8__detail16_Hashtable_allocISaINS_10_Hash_nodeISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEdELb1EEEEE21_M_deallocate_bucketsEPPNS_15_Hash_node_baseEy:
    #####: 2081:    _Hashtable_alloc<_NodeAlloc>::
        -: 2082:    _M_deallocate_buckets(__buckets_ptr __bkts,
        -: 2083:			  std::size_t __bkt_count)
        -: 2084:    {
        -: 2085:      typedef typename __buckets_alloc_traits::pointer _Ptr;
    #####: 2086:      auto __ptr = std::pointer_traits<_Ptr>::pointer_to(*__bkts);
    #####: 2087:      __buckets_alloc_type __alloc(_M_node_allocator());
        -: 2088:      __buckets_alloc_traits::deallocate(__alloc, __ptr, __bkt_count);
    #####: 2089:    }
------------------
_ZNSt8__detail16_Hashtable_allocISaINS_10_Hash_nodeISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES8_ELb1EEEEE21_M_deallocate_bucketsEPPNS_15_Hash_node_baseEy:
       21: 2081:    _Hashtable_alloc<_NodeAlloc>::
        -: 2082:    _M_deallocate_buckets(__buckets_ptr __bkts,
        -: 2083:			  std::size_t __bkt_count)
        -: 2084:    {
        -: 2085:      typedef typename __buckets_alloc_traits::pointer _Ptr;
       21: 2086:      auto __ptr = std::pointer_traits<_Ptr>::pointer_to(*__bkts);
       21: 2087:      __buckets_alloc_type __alloc(_M_node_allocator());
        -: 2088:      __buckets_alloc_traits::deallocate(__alloc, __ptr, __bkt_count);
       21: 2089:    }
------------------
_ZNSt8__detail16_Hashtable_allocISaINS_10_Hash_nodeISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEiELb1EEEEE21_M_deallocate_bucketsEPPNS_15_Hash_node_baseEy:
      105: 2081:    _Hashtable_alloc<_NodeAlloc>::
        -: 2082:    _M_deallocate_buckets(__buckets_ptr __bkts,
        -: 2083:			  std::size_t __bkt_count)
        -: 2084:    {
        -: 2085:      typedef typename __buckets_alloc_traits::pointer _Ptr;
      105: 2086:      auto __ptr = std::pointer_traits<_Ptr>::pointer_to(*__bkts);
      105: 2087:      __buckets_alloc_type __alloc(_M_node_allocator());
        -: 2088:      __buckets_alloc_traits::deallocate(__alloc, __ptr, __bkt_count);
      105: 2089:    }
------------------
_ZNSt8__detail16_Hashtable_allocISaINS_10_Hash_nodeINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEELb1EEEEE21_M_deallocate_bucketsEPPNS_15_Hash_node_baseEy:
    #####: 2081:    _Hashtable_alloc<_NodeAlloc>::
        -: 2082:    _M_deallocate_buckets(__buckets_ptr __bkts,
        -: 2083:			  std::size_t __bkt_count)
        -: 2084:    {
        -: 2085:      typedef typename __buckets_alloc_traits::pointer _Ptr;
    #####: 2086:      auto __ptr = std::pointer_traits<_Ptr>::pointer_to(*__bkts);
    #####: 2087:      __buckets_alloc_type __alloc(_M_node_allocator());
        -: 2088:      __buckets_alloc_traits::deallocate(__alloc, __ptr, __bkt_count);
    #####: 2089:    }
------------------
_ZNSt8__detail16_Hashtable_allocISaINS_10_Hash_nodeISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt6vectorIS8_SaIS8_EEELb1EEEEE21_M_deallocate_bucketsEPPNS_15_Hash_node_baseEy:
    #####: 2081:    _Hashtable_alloc<_NodeAlloc>::
        -: 2082:    _M_deallocate_buckets(__buckets_ptr __bkts,
        -: 2083:			  std::size_t __bkt_count)
        -: 2084:    {
        -: 2085:      typedef typename __buckets_alloc_traits::pointer _Ptr;
    #####: 2086:      auto __ptr = std::pointer_traits<_Ptr>::pointer_to(*__bkts);
    #####: 2087:      __buckets_alloc_type __alloc(_M_node_allocator());
        -: 2088:      __buckets_alloc_traits::deallocate(__alloc, __ptr, __bkt_count);
    #####: 2089:    }
------------------
_ZNSt8__detail16_Hashtable_allocISaINS_10_Hash_nodeISt4pairIKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESt13unordered_mapIS8_iSt4hashIS8_ESt8equal_toIS8_ESaIS2_IS9_iEEEELb1EEEEE21_M_deallocate_bucketsEPPNS_15_Hash_node_baseEy:
    #####: 2081:    _Hashtable_alloc<_NodeAlloc>::
        -: 2082:    _M_deallocate_buckets(__buckets_ptr __bkts,
        -: 2083:			  std::size_t __bkt_count)
        -: 2084:    {
        -: 2085:      typedef typename __buckets_alloc_traits::pointer _Ptr;
    #####: 2086:      auto __ptr = std::pointer_traits<_Ptr>::pointer_to(*__bkts);
    #####: 2087:      __buckets_alloc_type __alloc(_M_node_allocator());
        -: 2088:      __buckets_alloc_traits::deallocate(__alloc, __ptr, __bkt_count);
    #####: 2089:    }
------------------
        -: 2090:
        -: 2091: ///@} hashtable-detail
        -: 2092:} // namespace __detail
        -: 2093:/// @endcond
        -: 2094:_GLIBCXX_END_NAMESPACE_VERSION
        -: 2095:} // namespace std
        -: 2096:
        -: 2097:#endif // _HASHTABLE_POLICY_H
